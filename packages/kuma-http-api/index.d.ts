/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * The index endpoint
         * @description The index endpoint, some common metadata
         */
        get: operations["index"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/_resources": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * A list of all resources that exist
         * @description Returns a Global Insight object
         */
        get: operations["get-resource-type-description"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/global-insight": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Global Insight
         * @description Returns a Global Insight object
         */
        get: operations["get-global-insight"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/{resourceType}/{resourceName}/_rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns rules matching this dataplane
         * @description Returns rules matching this dataplane
         */
        get: operations["inspect-dataplanes-rules"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/dataplanes/{name}/_config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a proxy XDS config on a CP, this endpoint is only available on zone CPs.
         * @description Returns the [xds](https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol) configuration of the proxy.
         */
        get: operations["get-dataplanes-xds-config"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/dataplanes/{name}/_layout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get networking layout for this dataplane
         * @description Returns detailed dataplane networking layout with most important information on dataplane and list of its inbounds and outbounds
         */
        get: operations["get-dataplanes-layout"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/dataplanes/{name}/_policies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get proxy policies for this dataplane
         * @description Returns proxy level policy configuration derived from combining all proxy policies selecting this dataplane
         */
        get: operations["get-proxy-policy-conf"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/dataplanes/{name}/_inbounds/{inbound-kri}/_policies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get policies for this inbound
         * @description Returns inbound policy configuration derived from combining all policies selecting this dataplane
         */
        get: operations["get-inbound-policy-conf"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/dataplanes/{name}/_outbounds/{kri}/_policies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get policies for this outbound
         * @description Returns outbound policy configuration derived from combining all policies selecting this dataplane
         */
        get: operations["get-outbound-policy-conf"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/dataplanes/{name}/_outbounds/{kri}/_routes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get routes configuration for this outbound
         * @description Returns routes configuration derived from combining all routes on this outbound
         */
        get: operations["get-outbound-routes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/dataplanes/{name}/_outbounds/{outbound-kri}/_routes/{route-kri}/_policies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get policies for this route
         * @description Returns route policy configuration derived from combining all policies selecting this dataplane
         */
        get: operations["get-route-policy-conf"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/{policyType}/{policyName}/_resources/dataplanes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns resources matched by this policy
         * @description Returns resources matched by this policy. In the case of `targetRef` policies we'll match using the top level `targetRef`
         */
        get: operations["inspect-resources"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/{serviceType}/{serviceName}/_hostnames": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns hostnames for service
         * @description Returns hostnames for a service
         */
        get: operations["inspect-hostnames"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshaccesslogs/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshAccessLog entity */
        get: operations["getMeshAccessLog"];
        /** Creates or Updates MeshAccessLog entity */
        put: operations["putMeshAccessLog"];
        post?: never;
        /** Deletes MeshAccessLog entity */
        delete: operations["deleteMeshAccessLog"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshaccesslogs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshAccessLog in the mesh. */
        get: operations["getMeshAccessLogList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshcircuitbreakers/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshCircuitBreaker entity */
        get: operations["getMeshCircuitBreaker"];
        /** Creates or Updates MeshCircuitBreaker entity */
        put: operations["putMeshCircuitBreaker"];
        post?: never;
        /** Deletes MeshCircuitBreaker entity */
        delete: operations["deleteMeshCircuitBreaker"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshcircuitbreakers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshCircuitBreaker in the mesh. */
        get: operations["getMeshCircuitBreakerList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshfaultinjections/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshFaultInjection entity */
        get: operations["getMeshFaultInjection"];
        /** Creates or Updates MeshFaultInjection entity */
        put: operations["putMeshFaultInjection"];
        post?: never;
        /** Deletes MeshFaultInjection entity */
        delete: operations["deleteMeshFaultInjection"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshfaultinjections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshFaultInjection in the mesh. */
        get: operations["getMeshFaultInjectionList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshhealthchecks/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshHealthCheck entity */
        get: operations["getMeshHealthCheck"];
        /** Creates or Updates MeshHealthCheck entity */
        put: operations["putMeshHealthCheck"];
        post?: never;
        /** Deletes MeshHealthCheck entity */
        delete: operations["deleteMeshHealthCheck"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshhealthchecks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshHealthCheck in the mesh. */
        get: operations["getMeshHealthCheckList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshhttproutes/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshHTTPRoute entity */
        get: operations["getMeshHTTPRoute"];
        /** Creates or Updates MeshHTTPRoute entity */
        put: operations["putMeshHTTPRoute"];
        post?: never;
        /** Deletes MeshHTTPRoute entity */
        delete: operations["deleteMeshHTTPRoute"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshhttproutes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshHTTPRoute in the mesh. */
        get: operations["getMeshHTTPRouteList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshloadbalancingstrategies/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshLoadBalancingStrategy entity */
        get: operations["getMeshLoadBalancingStrategy"];
        /** Creates or Updates MeshLoadBalancingStrategy entity */
        put: operations["putMeshLoadBalancingStrategy"];
        post?: never;
        /** Deletes MeshLoadBalancingStrategy entity */
        delete: operations["deleteMeshLoadBalancingStrategy"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshloadbalancingstrategies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshLoadBalancingStrategy in the mesh. */
        get: operations["getMeshLoadBalancingStrategyList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshmetrics/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshMetric entity */
        get: operations["getMeshMetric"];
        /** Creates or Updates MeshMetric entity */
        put: operations["putMeshMetric"];
        post?: never;
        /** Deletes MeshMetric entity */
        delete: operations["deleteMeshMetric"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshmetrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshMetric in the mesh. */
        get: operations["getMeshMetricList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshpassthroughs/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshPassthrough entity */
        get: operations["getMeshPassthrough"];
        /** Creates or Updates MeshPassthrough entity */
        put: operations["putMeshPassthrough"];
        post?: never;
        /** Deletes MeshPassthrough entity */
        delete: operations["deleteMeshPassthrough"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshpassthroughs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshPassthrough in the mesh. */
        get: operations["getMeshPassthroughList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshproxypatches/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshProxyPatch entity */
        get: operations["getMeshProxyPatch"];
        /** Creates or Updates MeshProxyPatch entity */
        put: operations["putMeshProxyPatch"];
        post?: never;
        /** Deletes MeshProxyPatch entity */
        delete: operations["deleteMeshProxyPatch"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshproxypatches": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshProxyPatch in the mesh. */
        get: operations["getMeshProxyPatchList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshratelimits/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshRateLimit entity */
        get: operations["getMeshRateLimit"];
        /** Creates or Updates MeshRateLimit entity */
        put: operations["putMeshRateLimit"];
        post?: never;
        /** Deletes MeshRateLimit entity */
        delete: operations["deleteMeshRateLimit"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshratelimits": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshRateLimit in the mesh. */
        get: operations["getMeshRateLimitList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshretries/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshRetry entity */
        get: operations["getMeshRetry"];
        /** Creates or Updates MeshRetry entity */
        put: operations["putMeshRetry"];
        post?: never;
        /** Deletes MeshRetry entity */
        delete: operations["deleteMeshRetry"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshretries": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshRetry in the mesh. */
        get: operations["getMeshRetryList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshtcproutes/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshTCPRoute entity */
        get: operations["getMeshTCPRoute"];
        /** Creates or Updates MeshTCPRoute entity */
        put: operations["putMeshTCPRoute"];
        post?: never;
        /** Deletes MeshTCPRoute entity */
        delete: operations["deleteMeshTCPRoute"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshtcproutes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshTCPRoute in the mesh. */
        get: operations["getMeshTCPRouteList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshtimeouts/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshTimeout entity */
        get: operations["getMeshTimeout"];
        /** Creates or Updates MeshTimeout entity */
        put: operations["putMeshTimeout"];
        post?: never;
        /** Deletes MeshTimeout entity */
        delete: operations["deleteMeshTimeout"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshtimeouts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshTimeout in the mesh. */
        get: operations["getMeshTimeoutList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshtlses/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshTLS entity */
        get: operations["getMeshTLS"];
        /** Creates or Updates MeshTLS entity */
        put: operations["putMeshTLS"];
        post?: never;
        /** Deletes MeshTLS entity */
        delete: operations["deleteMeshTLS"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshtlses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshTLS in the mesh. */
        get: operations["getMeshTLSList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshtraces/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshTrace entity */
        get: operations["getMeshTrace"];
        /** Creates or Updates MeshTrace entity */
        put: operations["putMeshTrace"];
        post?: never;
        /** Deletes MeshTrace entity */
        delete: operations["deleteMeshTrace"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshtraces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshTrace in the mesh. */
        get: operations["getMeshTraceList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshtrafficpermissions/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshTrafficPermission entity */
        get: operations["getMeshTrafficPermission"];
        /** Creates or Updates MeshTrafficPermission entity */
        put: operations["putMeshTrafficPermission"];
        post?: never;
        /** Deletes MeshTrafficPermission entity */
        delete: operations["deleteMeshTrafficPermission"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshtrafficpermissions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshTrafficPermission in the mesh. */
        get: operations["getMeshTrafficPermissionList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/dataplanes/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns Dataplane entity */
        get: operations["getDataplane"];
        /** Creates or Updates Dataplane entity */
        put: operations["putDataplane"];
        post?: never;
        /** Deletes Dataplane entity */
        delete: operations["deleteDataplane"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/dataplanes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of Dataplane in the mesh. */
        get: operations["getDataplaneList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/dataplanes/{name}/_overview": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["getDataplaneOverview"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/dataplanes/_overview": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["getDataplaneOverviewList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns Mesh entity */
        get: operations["getMesh"];
        /** Creates or Updates Mesh entity */
        put: operations["putMesh"];
        post?: never;
        /** Deletes Mesh entity */
        delete: operations["deleteMesh"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of Mesh in the mesh. */
        get: operations["getMeshList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshgateways/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshGateway entity */
        get: operations["getMeshGateway"];
        /** Creates or Updates MeshGateway entity */
        put: operations["putMeshGateway"];
        post?: never;
        /** Deletes MeshGateway entity */
        delete: operations["deleteMeshGateway"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshgateways": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshGateway in the mesh. */
        get: operations["getMeshGatewayList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/hostnamegenerators/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns HostnameGenerator entity */
        get: operations["getHostnameGenerator"];
        /** Creates or Updates HostnameGenerator entity */
        put: operations["putHostnameGenerator"];
        post?: never;
        /** Deletes HostnameGenerator entity */
        delete: operations["deleteHostnameGenerator"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/hostnamegenerators": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of HostnameGenerator in the mesh. */
        get: operations["getHostnameGeneratorList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshexternalservices/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshExternalService entity */
        get: operations["getMeshExternalService"];
        /** Creates or Updates MeshExternalService entity */
        put: operations["putMeshExternalService"];
        post?: never;
        /** Deletes MeshExternalService entity */
        delete: operations["deleteMeshExternalService"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshexternalservices": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshExternalService in the mesh. */
        get: operations["getMeshExternalServiceList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshidentities/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshIdentity entity */
        get: operations["getMeshIdentity"];
        /** Creates or Updates MeshIdentity entity */
        put: operations["putMeshIdentity"];
        post?: never;
        /** Deletes MeshIdentity entity */
        delete: operations["deleteMeshIdentity"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshidentities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshIdentity in the mesh. */
        get: operations["getMeshIdentityList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshmultizoneservices/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshMultiZoneService entity */
        get: operations["getMeshMultiZoneService"];
        /** Creates or Updates MeshMultiZoneService entity */
        put: operations["putMeshMultiZoneService"];
        post?: never;
        /** Deletes MeshMultiZoneService entity */
        delete: operations["deleteMeshMultiZoneService"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshmultizoneservices": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshMultiZoneService in the mesh. */
        get: operations["getMeshMultiZoneServiceList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshservices/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshService entity */
        get: operations["getMeshService"];
        /** Creates or Updates MeshService entity */
        put: operations["putMeshService"];
        post?: never;
        /** Deletes MeshService entity */
        delete: operations["deleteMeshService"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshservices": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshService in the mesh. */
        get: operations["getMeshServiceList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshtrusts/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns MeshTrust entity */
        get: operations["getMeshTrust"];
        /** Creates or Updates MeshTrust entity */
        put: operations["putMeshTrust"];
        post?: never;
        /** Deletes MeshTrust entity */
        delete: operations["deleteMeshTrust"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/meshes/{mesh}/meshtrusts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a list of MeshTrust in the mesh. */
        get: operations["getMeshTrustList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description 200 */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ControlPlaneConfig"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/mesh-insights": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: {
            parameters: {
                query?: {
                    name?: components["parameters"]["name"];
                    size?: components["parameters"]["size"];
                    offset?: components["parameters"]["offset"];
                    filter?: components["parameters"]["filter"];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description 200 */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MeshInsightCollection"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/mesh-insights/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: {
            parameters: {
                query?: {
                    format?: components["parameters"]["format"];
                };
                header?: never;
                path: {
                    name: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description 200 */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MeshInsight"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * Index
         * @description Some metadata about the service
         */
        Index: {
            hostname: string;
            /** @description The product line (Kuma for OSS, different for other distributions) */
            product: string;
            /** @description The semantic version of the server running */
            version: string;
            /** @description A unique id to identify the instance requested */
            instanceId: string;
            /** @description A unique id to identify the cluster being connected to */
            clusterId: string;
            /** @description The path to the GUI */
            gui: string;
            /** @description In case of an alternative distribution of Kuma the Kuma version this release is based on */
            basedOnKuma?: string;
        };
        /**
         * ResourceTypeDescriptionList
         * @description A list of all resources install
         */
        ResourceTypeDescriptionList: {
            resources: components["schemas"]["ResourceTypeDescription"][];
        };
        /**
         * InspectDataplanesForPolicy
         * @description A list of proxies
         */
        InspectDataplanesForPolicy: {
            /** @example 200 */
            total: number;
            next?: string;
            items: components["schemas"]["Meta"][];
        };
        /** DataplaneXDSConfig */
        DataplaneXDSConfig: {
            /** @description The raw XDS config as an inline JSON object */
            xds: Record<string, never>;
            /** @description Contains a diff in a JSONPatch format between the XDS config returned in 'xds' and the current proxy XDS config.
             *     By default, the field is empty. To include the diff in the response, use the `include=diff` query parameter.
             *      */
            diff?: components["schemas"]["JsonPatchItem"][];
        };
        /**
         * InspectRules
         * @description A list of rules for a dataplane
         */
        InspectRules: {
            resource: components["schemas"]["Meta"];
            rules: components["schemas"]["InspectRule"][];
            httpMatches: components["schemas"]["HttpMatch"][];
        };
        /** Status */
        BaseStatus: {
            /** @example 10 */
            online: number;
            /** @example 30 */
            total: number;
        };
        FullStatus: components["schemas"]["BaseStatus"] & {
            /** @example 15 */
            offline: number;
            /** @example 5 */
            partiallyDegraded: number;
        };
        /**
         * ServicesStats
         * @description Services statistics
         */
        ServicesStats: {
            /** @description Internal services statistics */
            internal: components["schemas"]["FullStatus"];
            /** @description External services statistics */
            external: {
                /** @example 5 */
                total: number;
            };
            /** @description Builtin Gateway services statistics */
            gatewayBuiltin: components["schemas"]["FullStatus"];
            /** @description Delegated Gateway services statistics */
            gatewayDelegated: components["schemas"]["FullStatus"];
        };
        /**
         * Zones Stats
         * @description Zone statistics
         */
        ZonesStats: {
            /** @description Control Planes statistics */
            controlPlanes: components["schemas"]["BaseStatus"];
            /** @description Zone Egresses statistics */
            zoneEgresses: components["schemas"]["BaseStatus"];
            /** @description Zone Ingresses statistics */
            zoneIngresses: components["schemas"]["BaseStatus"];
        };
        /**
         * Dataplanes Stats
         * @description Dataplanes statistics
         */
        DataplanesStats: {
            /** @description Standard dataplane proxy statistics */
            standard: components["schemas"]["FullStatus"];
            /** @description Builtin Gateway dataplane proxy statistics */
            gatewayBuiltin: components["schemas"]["FullStatus"];
            /** @description Delegated Gateway dataplane proxy statistics */
            gatewayDelegated: components["schemas"]["FullStatus"];
        };
        /**
         * Policies Stats
         * @description Policies statistics
         */
        PoliciesStats: {
            /**
             * @description Number of policies
             * @example 30
             */
            total: number;
        };
        /**
         * Resource Stats
         * @description Resource statistics
         */
        ResourceStats: {
            /**
             * @description Number of resources
             * @example 30
             */
            total: number;
        };
        /**
         * Meshes Stats
         * @description Mesh statistics
         */
        MeshesStats: {
            /**
             * @description Number of meshes
             * @example 3
             */
            total: number;
        };
        /**
         * GlobalInsight
         * @description Global Insight contains statistics for all main resources
         */
        "schemas-GlobalInsight": {
            /**
             * Format: date-time
             * @description Time of Global Insight creation
             * @example 2023-01-11T02:30:42.227Z
             */
            createdAt: string;
            /** @description Mesh services statistics */
            services: components["schemas"]["ServicesStats"];
            /** @description Zones statistics */
            zones: components["schemas"]["ZonesStats"];
            /** @description Dataplane proxy statistics */
            dataplanes: components["schemas"]["DataplanesStats"];
            /** @description Policies statistics */
            policies: components["schemas"]["PoliciesStats"];
            /** @description Mesh statistics */
            meshes: components["schemas"]["MeshesStats"];
            /** @description A map of resource names to their corresponding statistics */
            resources: {
                [key: string]: components["schemas"]["ResourceStats"];
            };
        };
        GlobalInsight: components["schemas"]["schemas-GlobalInsight"];
        /**
         * InspectHostnames
         * @description A list of hostnames
         */
        InspectHostnames: {
            /** @example 200 */
            total: number;
            items: components["schemas"]["InspectHostname"][];
        };
        /**
         * InspectHostname
         * @description An supported hostname along with the zones it exists in
         */
        InspectHostname: {
            /**
             * @description Generated hostname
             * @example redis.redis-system.svc.east.mesh.local
             */
            hostname: string;
            zones: components["schemas"]["InspectHostnameZone"][];
        };
        /**
         * InspectHostnameZone
         * @description A name of the zone in which the hostname is available
         */
        InspectHostnameZone: {
            /** @example east */
            name: string;
        };
        /**
         * DataplaneLayout
         * @description Dataplane networking layout. It contains information most important information about dataplane and lists of available inbounds and outbounds
         */
        DataplaneNetworkingLayout: {
            /** @example kri_dp_default_default_kuma-demo_demo-app-75ff54499c-ttwd7_http-port */
            kri: string;
            /** @example {
             *       "k8s.kuma.io/namespace": "kuma-demo",
             *       "kuma.io/display-name": "demo-app",
             *       "kuma.io/mesh": "default",
             *       "kuma.io/origin": "zone"
             *     } */
            labels: {
                [key: string]: string;
            };
            inbounds: components["schemas"]["DataplaneInbound"][];
            outbounds: components["schemas"]["DataplaneOutbound"][];
        };
        /** Invalid Parameters */
        InvalidParameters: {
            field?: string;
            reason?: string;
            rule?: string;
            choices?: string[];
        };
        /**
         * Error
         * @description standard error
         */
        Error: {
            /**
             * @description The HTTP status code.
             * @example 404
             */
            status: number;
            /**
             * @description The error response code.
             * @example Not Found
             */
            title: string;
            /**
             * @description The error type.
             * @example Not Found
             */
            type?: string;
            /**
             * @description The portal traceback code
             * @example portal:trace:2287285207635123011
             */
            instance: string;
            /**
             * @description Details about the error.
             * @example The requested team was not found
             */
            detail?: string;
            /** @description TODO */
            invalid_parameters?: components["schemas"]["InvalidParameters"][];
        };
        /** @description information about a policy */
        PolicyDescription: {
            /** @description whether this policy uses targetRef matching */
            isTargetRef: boolean;
            /** @description indicates that this policy can be used as an outbound policy */
            hasToTargetRef: boolean;
            /** @description indicates that this policy can be used as an inbound policy */
            hasFromTargetRef: boolean;
            /** @description If set to `true`, performs a backward compatibility conversion from the deprecated 'from' array to the new 'rules' array. This ensures older policies remain functional under the updated schema. */
            isFromAsRules: boolean;
        };
        /** @description Description of a resource type, this is useful for dynamically generated clients and the gui */
        ResourceTypeDescription: {
            /** @description the name of the resource type */
            name: string;
            /** @enum {string} */
            scope: "Global" | "Mesh";
            readOnly: boolean;
            /** @description the path to use for accessing this resource. If scope is `Global` then it will be `/<path>` otherwise it will be `/meshes/<path>` */
            path: string;
            singularDisplayName: string;
            pluralDisplayName: string;
            /** @description description resources of this type should be included in federetion-with-policies export profile (especially useful for moving from non-federated to federated or migrating to a new global). */
            includeInFederation: boolean;
            policy?: components["schemas"]["PolicyDescription"];
        };
        Meta: {
            /**
             * @description the type of this resource
             * @example Dataplane
             */
            type: string;
            /**
             * @description the mesh this resource is part of
             * @example default
             */
            mesh: string;
            /**
             * @description the name of the resource
             * @example my-resource
             */
            name: string;
            /**
             * @description the label of the resource
             * @example {
             *       "k8s.kuma.io/namespace": "kuma-system",
             *       "kuma.io/display-name": "mtp",
             *       "kuma.io/mesh": "default",
             *       "kuma.io/origin": "zone"
             *     }
             */
            labels: {
                [key: string]: string;
            };
        };
        /** @description a rule that affects the entire proxy */
        ProxyRule: {
            /** @description The actual conf generated */
            conf: {
                [key: string]: unknown;
            };
            origin: components["schemas"]["Meta"][];
        };
        /** @description A matcher to select which traffic this conf applies to */
        RuleMatcher: {
            /**
             * @description the key to match against
             * @example kuma.io/service
             */
            key: string;
            /**
             * @description the value for the key to match against
             * @example my-cool-service
             */
            value: string;
            /** @description whether we check on the absence of this key:value pair */
            not: boolean;
        };
        Rule: {
            matchers: components["schemas"]["RuleMatcher"][];
            /** @description The actual conf generated */
            conf: {
                [key: string]: unknown;
            };
            origin: components["schemas"]["Meta"][];
        };
        ResourceRuleOrigin: {
            resourceMeta?: components["schemas"]["Meta"];
            /** @description index of the to-item in the policy */
            ruleIndex?: number;
        };
        ResourceRule: {
            resourceMeta: components["schemas"]["Meta"];
            resourceSectionName?: string;
            /** @description The actual conf generated */
            conf: {
                [key: string]: unknown;
            }[];
            /** @description The list of policies that contributed to the 'conf'. The order is important as it reflects in what order confs were merged to get the resulting 'conf'. */
            origin: components["schemas"]["ResourceRuleOrigin"][];
        };
        Inbound: {
            name?: string;
            tags: {
                [key: string]: string;
            };
            port: number;
        };
        FromRule: {
            inbound: components["schemas"]["Inbound"];
            rules: components["schemas"]["Rule"][];
        };
        InboundRule: {
            /** @description The final computed configuration for the data plane proxy, derived by merging all policies whose 'targetRef' field matches the proxy. The merging process follows [RFC 7396 (JSON Merge Patch)](https://datatracker.ietf.org/doc/html/rfc7396), with the order of merging influenced by factors such as where the policy was applied (e.g., custom namespace, system, or global control plane), policy role, and targetRef specificity. */
            conf: {
                [key: string]: unknown;
            }[];
            /** @description The list of policies that contributed to the 'conf'. The order is important as it reflects in what order confs were merged to get the resulting 'conf'. */
            origin: components["schemas"]["ResourceRuleOrigin"][];
        };
        InboundRulesEntry: {
            inbound: components["schemas"]["Inbound"];
            /** @description The 'rules' field is an array to allow for future expansion when 'matches' conditions are added. Currently, it contains a single item. */
            rules: components["schemas"]["InboundRule"][];
        };
        InspectRule: {
            /**
             * @description the type of the policy
             * @example MeshRetry
             */
            type: string;
            proxyRule?: components["schemas"]["ProxyRule"];
            /** @description a set of rules for the outbounds of this proxy. The field is not set when 'meshService.mode' on Mesh is set to 'Exclusive'. */
            toRules?: components["schemas"]["Rule"][];
            /** @description a set of rules for the outbounds produced by real resources (i.e MeshService, MeshExternalService, MeshMultiZoneService). */
            toResourceRules?: components["schemas"]["ResourceRule"][];
            /** @description a set of rules for each inbound of this proxy */
            fromRules?: components["schemas"]["FromRule"][];
            /** @description a set of rules for each inbound port of the proxy. When the policy descriptor has 'isFromAsRules' set to true, this field supersedes 'fromRules' and should be used instead. */
            inboundRules?: components["schemas"]["InboundRulesEntry"][];
            /**
             * @description a set of warnings to show in policy matching
             * @example [
             *       "Mesh is not Mtls enabled this policy will have no effect"
             *     ]
             */
            warnings?: string[];
        };
        HttpMatch: {
            hash: string;
            match: Record<string, never>;
        };
        JsonPatchItem: {
            /**
             * @description Operation to be performed.
             * @enum {string}
             */
            op: "add" | "remove" | "test";
            /** @description A JSON Pointer path indicating the part of the document to operate on. */
            path: string;
            /** @description The value to be used within the operations. */
            value: unknown;
        };
        DataplaneInbound: {
            kri: string;
            port: number;
            protocol: string;
            proxyResourceName: string;
        };
        DataplaneOutbound: {
            kri: string;
            port: number;
            protocol: string;
            proxyResourceName: string;
        };
        /** @description The list of policies KRI that contributed to the 'conf'. The order is important as it reflects in what order confs were merged to get the resulting 'conf'. */
        PolicyOrigin: {
            kri: string;
        };
        PolicyConf: {
            kind: string;
            /** @description The final computed configuration for the data plane proxy, derived by merging all policies whose 'targetRef' field matches the proxy. The merging process follows [RFC 7396 (JSON Merge Patch)](https://datatracker.ietf.org/doc/html/rfc7396), with the order of merging influenced by factors such as where the policy was applied (e.g., custom namespace, system, or global control plane), policy role, and targetRef specificity. */
            conf: {
                [key: string]: unknown;
            };
            /** @description The list of policies KRI that contributed to the 'conf'. The order is important as it reflects in what order confs were merged to get the resulting 'conf'. */
            origins: components["schemas"]["PolicyOrigin"][];
        };
        PoliciesList: {
            /** @description The final computed configuration, derived by merging all policies whose 'targetRef' field matches the proxy. The merging process follows [RFC 7396 (JSON Merge Patch)](https://datatracker.ietf.org/doc/html/rfc7396), with the order of merging influenced by factors such as where the policy was applied (e.g., custom namespace, system, or global control plane), policy role, and targetRef specificity. */
            policies: components["schemas"]["PolicyConf"][];
        };
        PolicyRule: {
            /** @description The final computed configuration for the data plane proxy, derived by merging all policies whose 'targetRef' field matches the proxy. The merging process follows [RFC 7396 (JSON Merge Patch)](https://datatracker.ietf.org/doc/html/rfc7396), with the order of merging influenced by factors such as where the policy was applied (e.g., custom namespace, system, or global control plane), policy role, and targetRef specificity. */
            conf: {
                [key: string]: unknown;
            };
            kri?: string;
        };
        InboundPolicyConf: {
            kind: string;
            rules: components["schemas"]["PolicyRule"][];
            /** @description The list of policies KRI that contributed to the 'conf'. The order is important as it reflects in what order confs were merged to get the resulting 'conf'. */
            origins: components["schemas"]["PolicyOrigin"][];
        };
        InboundPoliciesList: {
            /** @description The final computed configuration, derived by merging all policies whose 'targetRef' field matches the proxy. The merging process follows [RFC 7396 (JSON Merge Patch)](https://datatracker.ietf.org/doc/html/rfc7396), with the order of merging influenced by factors such as where the policy was applied (e.g., custom namespace, system, or global control plane), policy role, and targetRef specificity. */
            policies: components["schemas"]["InboundPolicyConf"][];
        };
        RouteRules: {
            kri: string;
            /** @description List of matches for which this rule will apply */
            matches: {
                [key: string]: unknown;
            }[];
            /** @description The final computed configuration for the data plane proxy, derived by merging all policies whose 'targetRef' field matches the proxy. The merging process follows [RFC 7396 (JSON Merge Patch)](https://datatracker.ietf.org/doc/html/rfc7396), with the order of merging influenced by factors such as where the policy was applied (e.g., custom namespace, system, or global control plane), policy role, and targetRef specificity. */
            conf: {
                [key: string]: unknown;
            };
        };
        RouteConf: {
            kind: string;
            /** @description Computed list of routing rules */
            rules: components["schemas"]["RouteRules"][];
            /** @description The list of policies KRI that contributed to the 'conf'. The order is important as it reflects in what order confs were merged to get the resulting 'conf'. */
            origins: components["schemas"]["PolicyOrigin"][];
        };
        RoutesList: {
            /** @description Computed list of routes */
            routes: components["schemas"]["RouteConf"][];
        };
        NotFoundError: components["schemas"]["Error"] & {
            /** @example 404 */
            status?: unknown;
            /** @example Not Found */
            title?: unknown;
            /** @example https://httpstatuses.com/404 */
            type?: unknown;
            /** @example kong:trace:1234567890 */
            instance?: unknown;
            /** @example Not found */
            detail?: unknown;
        };
        MeshAccessLogItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshAccessLog";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshAccessLog resource. */
            spec: {
                /** @description From list makes a match between clients and corresponding configurations */
                from?: {
                    /** @description Default is a configuration specific to the group of clients referenced in
                     *     'targetRef' */
                    default: {
                        backends?: {
                            /** @description FileBackend defines configuration for file based access logs */
                            file?: {
                                /** @description Format of access logs. Placeholders available on
                                 *     https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators */
                                format?: {
                                    /** @example [
                                     *       {
                                     *         "key": "start_time",
                                     *         "value": "%START_TIME%"
                                     *       },
                                     *       {
                                     *         "key": "bytes_received",
                                     *         "value": "%BYTES_RECEIVED%"
                                     *       }
                                     *     ] */
                                    json?: {
                                        key: string;
                                        value: string;
                                    }[];
                                    /** @default false */
                                    omitEmptyValues: boolean;
                                    /** @example [%START_TIME%] %KUMA_MESH% %UPSTREAM_HOST% */
                                    plain?: string;
                                    /** @enum {string} */
                                    type: "Plain" | "Json";
                                };
                                /**
                                 * @description Path to a file that logs will be written to
                                 * @example /tmp/access.log
                                 */
                                path: string;
                            };
                            /** @description Defines an OpenTelemetry logging backend. */
                            openTelemetry?: {
                                /**
                                 * @description Attributes can contain placeholders available on
                                 *     https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
                                 * @example [
                                 *       {
                                 *         "key": "mesh",
                                 *         "value": "%KUMA_MESH%"
                                 *       }
                                 *     ]
                                 */
                                attributes?: {
                                    key: string;
                                    value: string;
                                }[];
                                /**
                                 * @description Body is a raw string or an OTLP any value as described at
                                 *     https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#field-body
                                 *     It can contain placeholders available on
                                 *     https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
                                 * @example {
                                 *       "kvlistValue": {
                                 *         "values": [
                                 *           {
                                 *             "key": "mesh",
                                 *             "value": {
                                 *               "stringValue": "%KUMA_MESH%"
                                 *             }
                                 *           }
                                 *         ]
                                 *       }
                                 *     }
                                 */
                                body?: unknown;
                                /**
                                 * @description Endpoint of OpenTelemetry collector. An empty port defaults to 4317.
                                 * @example otel-collector:4317
                                 */
                                endpoint: string;
                            };
                            /** @description TCPBackend defines a TCP logging backend. */
                            tcp?: {
                                /**
                                 * @description Address of the TCP logging backend
                                 * @example 127.0.0.1:5000
                                 */
                                address: string;
                                /** @description Format of access logs. Placeholders available on
                                 *     https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators */
                                format?: {
                                    /** @example [
                                     *       {
                                     *         "key": "start_time",
                                     *         "value": "%START_TIME%"
                                     *       },
                                     *       {
                                     *         "key": "bytes_received",
                                     *         "value": "%BYTES_RECEIVED%"
                                     *       }
                                     *     ] */
                                    json?: {
                                        key: string;
                                        value: string;
                                    }[];
                                    /** @default false */
                                    omitEmptyValues: boolean;
                                    /** @example [%START_TIME%] %KUMA_MESH% %UPSTREAM_HOST% */
                                    plain?: string;
                                    /** @enum {string} */
                                    type: "Plain" | "Json";
                                };
                            };
                            /** @enum {string} */
                            type: "Tcp" | "File" | "OpenTelemetry";
                        }[];
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     clients. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
                /** @description Rules defines inbound access log configurations. Currently limited to
                 *     selecting all inbound traffic, as L7 matching is not yet implemented. */
                rules?: {
                    /** @description Default contains configuration of the inbound access logging */
                    default: {
                        backends?: {
                            /** @description FileBackend defines configuration for file based access logs */
                            file?: {
                                /** @description Format of access logs. Placeholders available on
                                 *     https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators */
                                format?: {
                                    /** @example [
                                     *       {
                                     *         "key": "start_time",
                                     *         "value": "%START_TIME%"
                                     *       },
                                     *       {
                                     *         "key": "bytes_received",
                                     *         "value": "%BYTES_RECEIVED%"
                                     *       }
                                     *     ] */
                                    json?: {
                                        key: string;
                                        value: string;
                                    }[];
                                    /** @default false */
                                    omitEmptyValues: boolean;
                                    /** @example [%START_TIME%] %KUMA_MESH% %UPSTREAM_HOST% */
                                    plain?: string;
                                    /** @enum {string} */
                                    type: "Plain" | "Json";
                                };
                                /**
                                 * @description Path to a file that logs will be written to
                                 * @example /tmp/access.log
                                 */
                                path: string;
                            };
                            /** @description Defines an OpenTelemetry logging backend. */
                            openTelemetry?: {
                                /**
                                 * @description Attributes can contain placeholders available on
                                 *     https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
                                 * @example [
                                 *       {
                                 *         "key": "mesh",
                                 *         "value": "%KUMA_MESH%"
                                 *       }
                                 *     ]
                                 */
                                attributes?: {
                                    key: string;
                                    value: string;
                                }[];
                                /**
                                 * @description Body is a raw string or an OTLP any value as described at
                                 *     https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#field-body
                                 *     It can contain placeholders available on
                                 *     https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
                                 * @example {
                                 *       "kvlistValue": {
                                 *         "values": [
                                 *           {
                                 *             "key": "mesh",
                                 *             "value": {
                                 *               "stringValue": "%KUMA_MESH%"
                                 *             }
                                 *           }
                                 *         ]
                                 *       }
                                 *     }
                                 */
                                body?: unknown;
                                /**
                                 * @description Endpoint of OpenTelemetry collector. An empty port defaults to 4317.
                                 * @example otel-collector:4317
                                 */
                                endpoint: string;
                            };
                            /** @description TCPBackend defines a TCP logging backend. */
                            tcp?: {
                                /**
                                 * @description Address of the TCP logging backend
                                 * @example 127.0.0.1:5000
                                 */
                                address: string;
                                /** @description Format of access logs. Placeholders available on
                                 *     https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators */
                                format?: {
                                    /** @example [
                                     *       {
                                     *         "key": "start_time",
                                     *         "value": "%START_TIME%"
                                     *       },
                                     *       {
                                     *         "key": "bytes_received",
                                     *         "value": "%BYTES_RECEIVED%"
                                     *       }
                                     *     ] */
                                    json?: {
                                        key: string;
                                        value: string;
                                    }[];
                                    /** @default false */
                                    omitEmptyValues: boolean;
                                    /** @example [%START_TIME%] %KUMA_MESH% %UPSTREAM_HOST% */
                                    plain?: string;
                                    /** @enum {string} */
                                    type: "Plain" | "Json";
                                };
                            };
                            /** @enum {string} */
                            type: "Tcp" | "File" | "OpenTelemetry";
                        }[];
                    };
                }[];
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined in-place. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
                /** @description To list makes a match between the consumed services and corresponding configurations */
                to?: {
                    /** @description Default is a configuration specific to the group of destinations referenced in
                     *     'targetRef' */
                    default: {
                        backends?: {
                            /** @description FileBackend defines configuration for file based access logs */
                            file?: {
                                /** @description Format of access logs. Placeholders available on
                                 *     https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators */
                                format?: {
                                    /** @example [
                                     *       {
                                     *         "key": "start_time",
                                     *         "value": "%START_TIME%"
                                     *       },
                                     *       {
                                     *         "key": "bytes_received",
                                     *         "value": "%BYTES_RECEIVED%"
                                     *       }
                                     *     ] */
                                    json?: {
                                        key: string;
                                        value: string;
                                    }[];
                                    /** @default false */
                                    omitEmptyValues: boolean;
                                    /** @example [%START_TIME%] %KUMA_MESH% %UPSTREAM_HOST% */
                                    plain?: string;
                                    /** @enum {string} */
                                    type: "Plain" | "Json";
                                };
                                /**
                                 * @description Path to a file that logs will be written to
                                 * @example /tmp/access.log
                                 */
                                path: string;
                            };
                            /** @description Defines an OpenTelemetry logging backend. */
                            openTelemetry?: {
                                /**
                                 * @description Attributes can contain placeholders available on
                                 *     https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
                                 * @example [
                                 *       {
                                 *         "key": "mesh",
                                 *         "value": "%KUMA_MESH%"
                                 *       }
                                 *     ]
                                 */
                                attributes?: {
                                    key: string;
                                    value: string;
                                }[];
                                /**
                                 * @description Body is a raw string or an OTLP any value as described at
                                 *     https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#field-body
                                 *     It can contain placeholders available on
                                 *     https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators
                                 * @example {
                                 *       "kvlistValue": {
                                 *         "values": [
                                 *           {
                                 *             "key": "mesh",
                                 *             "value": {
                                 *               "stringValue": "%KUMA_MESH%"
                                 *             }
                                 *           }
                                 *         ]
                                 *       }
                                 *     }
                                 */
                                body?: unknown;
                                /**
                                 * @description Endpoint of OpenTelemetry collector. An empty port defaults to 4317.
                                 * @example otel-collector:4317
                                 */
                                endpoint: string;
                            };
                            /** @description TCPBackend defines a TCP logging backend. */
                            tcp?: {
                                /**
                                 * @description Address of the TCP logging backend
                                 * @example 127.0.0.1:5000
                                 */
                                address: string;
                                /** @description Format of access logs. Placeholders available on
                                 *     https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators */
                                format?: {
                                    /** @example [
                                     *       {
                                     *         "key": "start_time",
                                     *         "value": "%START_TIME%"
                                     *       },
                                     *       {
                                     *         "key": "bytes_received",
                                     *         "value": "%BYTES_RECEIVED%"
                                     *       }
                                     *     ] */
                                    json?: {
                                        key: string;
                                        value: string;
                                    }[];
                                    /** @default false */
                                    omitEmptyValues: boolean;
                                    /** @example [%START_TIME%] %KUMA_MESH% %UPSTREAM_HOST% */
                                    plain?: string;
                                    /** @enum {string} */
                                    type: "Plain" | "Json";
                                };
                            };
                            /** @enum {string} */
                            type: "Tcp" | "File" | "OpenTelemetry";
                        }[];
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     destinations. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshAccessLogCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshAccessLogDeleteSuccessResponse: Record<string, never>;
        MeshCircuitBreakerItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshCircuitBreaker";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshCircuitBreaker resource. */
            spec: {
                /** @description From list makes a match between clients and corresponding configurations */
                from?: {
                    /** @description Default is a configuration specific to the group of destinations
                     *     referenced in 'targetRef' */
                    default?: {
                        /** @description ConnectionLimits contains configuration of each circuit breaking limit,
                         *     which when exceeded makes the circuit breaker to become open (no traffic
                         *     is allowed like no current is allowed in the circuits when physical
                         *     circuit breaker ir open) */
                        connectionLimits?: {
                            /**
                             * Format: int32
                             * @description The maximum number of connection pools per cluster that are concurrently
                             *     supported at once. Set this for clusters which create a large number of
                             *     connection pools.
                             */
                            maxConnectionPools?: number;
                            /**
                             * Format: int32
                             * @description The maximum number of connections allowed to be made to the upstream
                             *     cluster.
                             */
                            maxConnections?: number;
                            /**
                             * Format: int32
                             * @description The maximum number of pending requests that are allowed to the upstream
                             *     cluster. This limit is applied as a connection limit for non-HTTP
                             *     traffic.
                             */
                            maxPendingRequests?: number;
                            /**
                             * Format: int32
                             * @description The maximum number of parallel requests that are allowed to be made
                             *     to the upstream cluster. This limit does not apply to non-HTTP traffic.
                             */
                            maxRequests?: number;
                            /**
                             * Format: int32
                             * @description The maximum number of parallel retries that will be allowed to
                             *     the upstream cluster.
                             */
                            maxRetries?: number;
                        };
                        /** @description OutlierDetection contains the configuration of the process of dynamically
                         *     determining whether some number of hosts in an upstream cluster are
                         *     performing unlike the others and removing them from the healthy load
                         *     balancing set. Performance might be along different axes such as
                         *     consecutive failures, temporal success rate, temporal latency, etc.
                         *     Outlier detection is a form of passive health checking. */
                        outlierDetection?: {
                            /** @description The base time that a host is ejected for. The real time is equal to
                             *     the base time multiplied by the number of times the host has been
                             *     ejected. */
                            baseEjectionTime?: string;
                            /** @description Contains configuration for supported outlier detectors */
                            detectors?: {
                                /** @description Failure Percentage based outlier detection functions similarly to success
                                 *     rate detection, in that it relies on success rate data from each host in
                                 *     a cluster. However, rather than compare those values to the mean success
                                 *     rate of the cluster as a whole, they are compared to a flat
                                 *     user-configured threshold. This threshold is configured via the
                                 *     outlierDetection.failurePercentageThreshold field.
                                 *     The other configuration fields for failure percentage based detection are
                                 *     similar to the fields for success rate detection. As with success rate
                                 *     detection, detection will not be performed for a host if its request
                                 *     volume over the aggregation interval is less than the
                                 *     outlierDetection.detectors.failurePercentage.requestVolume value.
                                 *     Detection also will not be performed for a cluster if the number of hosts
                                 *     with the minimum required request volume in an interval is less than the
                                 *     outlierDetection.detectors.failurePercentage.minimumHosts value. */
                                failurePercentage?: {
                                    /**
                                     * Format: int32
                                     * @description The minimum number of hosts in a cluster in order to perform failure
                                     *     percentage-based ejection. If the total number of hosts in the cluster is
                                     *     less than this value, failure percentage-based ejection will not be
                                     *     performed.
                                     */
                                    minimumHosts?: number;
                                    /**
                                     * Format: int32
                                     * @description The minimum number of total requests that must be collected in one
                                     *     interval (as defined by the interval duration above) to perform failure
                                     *     percentage-based ejection for this host. If the volume is lower than this
                                     *     setting, failure percentage-based ejection will not be performed for this
                                     *     host.
                                     */
                                    requestVolume?: number;
                                    /**
                                     * Format: int32
                                     * @description The failure percentage to use when determining failure percentage-based
                                     *     outlier detection. If the failure percentage of a given host is greater
                                     *     than or equal to this value, it will be ejected.
                                     */
                                    threshold?: number;
                                };
                                /** @description In the default mode (outlierDetection.splitExternalLocalOriginErrors is
                                 *     false) this detection type takes into account a subset of 5xx errors,
                                 *     called "gateway errors" (502, 503 or 504 status code) and local origin
                                 *     failures, such as timeout, TCP reset etc.
                                 *     In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
                                 *     this detection type takes into account a subset of 5xx errors, called
                                 *     "gateway errors" (502, 503 or 504 status code) and is supported only by
                                 *     the http router. */
                                gatewayFailures?: {
                                    /**
                                     * Format: int32
                                     * @description The number of consecutive gateway failures (502, 503, 504 status codes)
                                     *     before a consecutive gateway failure ejection occurs.
                                     */
                                    consecutive?: number;
                                };
                                /** @description This detection type is enabled only when
                                 *     outlierDetection.splitExternalLocalOriginErrors is true and takes into
                                 *     account only locally originated errors (timeout, reset, etc).
                                 *     If Envoy repeatedly cannot connect to an upstream host or communication
                                 *     with the upstream host is repeatedly interrupted, it will be ejected.
                                 *     Various locally originated problems are detected: timeout, TCP reset,
                                 *     ICMP errors, etc. This detection type is supported by http router and
                                 *     tcp proxy. */
                                localOriginFailures?: {
                                    /**
                                     * Format: int32
                                     * @description The number of consecutive locally originated failures before ejection
                                     *     occurs. Parameter takes effect only when splitExternalAndLocalErrors
                                     *     is set to true.
                                     */
                                    consecutive?: number;
                                };
                                /** @description Success Rate based outlier detection aggregates success rate data from
                                 *     every host in a cluster. Then at given intervals ejects hosts based on
                                 *     statistical outlier detection. Success Rate outlier detection will not be
                                 *     calculated for a host if its request volume over the aggregation interval
                                 *     is less than the outlierDetection.detectors.successRate.requestVolume
                                 *     value.
                                 *     Moreover, detection will not be performed for a cluster if the number of
                                 *     hosts with the minimum required request volume in an interval is less
                                 *     than the outlierDetection.detectors.successRate.minimumHosts value.
                                 *     In the default configuration mode
                                 *     (outlierDetection.splitExternalLocalOriginErrors is false) this detection
                                 *     type takes into account all types of errors: locally and externally
                                 *     originated.
                                 *     In split mode (outlierDetection.splitExternalLocalOriginErrors is true),
                                 *     locally originated errors and externally originated (transaction) errors
                                 *     are counted and treated separately. */
                                successRate?: {
                                    /**
                                     * Format: int32
                                     * @description The number of hosts in a cluster that must have enough request volume to
                                     *     detect success rate outliers. If the number of hosts is less than this
                                     *     setting, outlier detection via success rate statistics is not performed
                                     *     for any host in the cluster.
                                     */
                                    minimumHosts?: number;
                                    /**
                                     * Format: int32
                                     * @description The minimum number of total requests that must be collected in one
                                     *     interval (as defined by the interval duration configured in
                                     *     outlierDetection section) to include this host in success rate based
                                     *     outlier detection. If the volume is lower than this setting, outlier
                                     *     detection via success rate statistics is not performed for that host.
                                     */
                                    requestVolume?: number;
                                    /** @description This factor is used to determine the ejection threshold for success rate
                                     *     outlier ejection. The ejection threshold is the difference between
                                     *     the mean success rate, and the product of this factor and the standard
                                     *     deviation of the mean success rate: mean - (standard_deviation *
                                     *     success_rate_standard_deviation_factor).
                                     *     Either int or decimal represented as string. */
                                    standardDeviationFactor?: number | string;
                                };
                                /** @description In the default mode (outlierDetection.splitExternalAndLocalErrors is
                                 *     false) this detection type takes into account all generated errors:
                                 *     locally originated and externally originated (transaction) errors.
                                 *     In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
                                 *     this detection type takes into account only externally originated
                                 *     (transaction) errors, ignoring locally originated errors.
                                 *     If an upstream host is an HTTP-server, only 5xx types of error are taken
                                 *     into account (see Consecutive Gateway Failure for exceptions).
                                 *     Properly formatted responses, even when they carry an operational error
                                 *     (like index not found, access denied) are not taken into account. */
                                totalFailures?: {
                                    /**
                                     * Format: int32
                                     * @description The number of consecutive server-side error responses (for HTTP traffic,
                                     *     5xx responses; for TCP traffic, connection failures; for Redis, failure
                                     *     to respond PONG; etc.) before a consecutive total failure ejection
                                     *     occurs.
                                     */
                                    consecutive?: number;
                                };
                            };
                            /** @description When set to true, outlierDetection configuration won't take any effect */
                            disabled?: boolean;
                            /** @description Allows to configure panic threshold for Envoy cluster. If not specified,
                             *     the default is 50%. To disable panic mode, set to 0%.
                             *     Either int or decimal represented as string. */
                            healthyPanicThreshold?: number | string;
                            /** @description The time interval between ejection analysis sweeps. This can result in
                             *     both new ejections and hosts being returned to service. */
                            interval?: string;
                            /**
                             * Format: int32
                             * @description The maximum % of an upstream cluster that can be ejected due to outlier
                             *     detection. Defaults to 10% but will eject at least one host regardless of
                             *     the value.
                             */
                            maxEjectionPercent?: number;
                            /** @description Determines whether to distinguish local origin failures from external
                             *     errors. If set to true the following configuration parameters are taken
                             *     into account: detectors.localOriginFailures.consecutive */
                            splitExternalAndLocalErrors?: boolean;
                        };
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     destinations. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
                /** @description Rules defines inbound circuit breaker configurations. Currently limited to
                 *     selecting all inbound traffic, as L7 matching is not yet implemented. */
                rules?: {
                    /** @description Default contains configuration of the inbound circuit breaker */
                    default?: {
                        /** @description ConnectionLimits contains configuration of each circuit breaking limit,
                         *     which when exceeded makes the circuit breaker to become open (no traffic
                         *     is allowed like no current is allowed in the circuits when physical
                         *     circuit breaker ir open) */
                        connectionLimits?: {
                            /**
                             * Format: int32
                             * @description The maximum number of connection pools per cluster that are concurrently
                             *     supported at once. Set this for clusters which create a large number of
                             *     connection pools.
                             */
                            maxConnectionPools?: number;
                            /**
                             * Format: int32
                             * @description The maximum number of connections allowed to be made to the upstream
                             *     cluster.
                             */
                            maxConnections?: number;
                            /**
                             * Format: int32
                             * @description The maximum number of pending requests that are allowed to the upstream
                             *     cluster. This limit is applied as a connection limit for non-HTTP
                             *     traffic.
                             */
                            maxPendingRequests?: number;
                            /**
                             * Format: int32
                             * @description The maximum number of parallel requests that are allowed to be made
                             *     to the upstream cluster. This limit does not apply to non-HTTP traffic.
                             */
                            maxRequests?: number;
                            /**
                             * Format: int32
                             * @description The maximum number of parallel retries that will be allowed to
                             *     the upstream cluster.
                             */
                            maxRetries?: number;
                        };
                        /** @description OutlierDetection contains the configuration of the process of dynamically
                         *     determining whether some number of hosts in an upstream cluster are
                         *     performing unlike the others and removing them from the healthy load
                         *     balancing set. Performance might be along different axes such as
                         *     consecutive failures, temporal success rate, temporal latency, etc.
                         *     Outlier detection is a form of passive health checking. */
                        outlierDetection?: {
                            /** @description The base time that a host is ejected for. The real time is equal to
                             *     the base time multiplied by the number of times the host has been
                             *     ejected. */
                            baseEjectionTime?: string;
                            /** @description Contains configuration for supported outlier detectors */
                            detectors?: {
                                /** @description Failure Percentage based outlier detection functions similarly to success
                                 *     rate detection, in that it relies on success rate data from each host in
                                 *     a cluster. However, rather than compare those values to the mean success
                                 *     rate of the cluster as a whole, they are compared to a flat
                                 *     user-configured threshold. This threshold is configured via the
                                 *     outlierDetection.failurePercentageThreshold field.
                                 *     The other configuration fields for failure percentage based detection are
                                 *     similar to the fields for success rate detection. As with success rate
                                 *     detection, detection will not be performed for a host if its request
                                 *     volume over the aggregation interval is less than the
                                 *     outlierDetection.detectors.failurePercentage.requestVolume value.
                                 *     Detection also will not be performed for a cluster if the number of hosts
                                 *     with the minimum required request volume in an interval is less than the
                                 *     outlierDetection.detectors.failurePercentage.minimumHosts value. */
                                failurePercentage?: {
                                    /**
                                     * Format: int32
                                     * @description The minimum number of hosts in a cluster in order to perform failure
                                     *     percentage-based ejection. If the total number of hosts in the cluster is
                                     *     less than this value, failure percentage-based ejection will not be
                                     *     performed.
                                     */
                                    minimumHosts?: number;
                                    /**
                                     * Format: int32
                                     * @description The minimum number of total requests that must be collected in one
                                     *     interval (as defined by the interval duration above) to perform failure
                                     *     percentage-based ejection for this host. If the volume is lower than this
                                     *     setting, failure percentage-based ejection will not be performed for this
                                     *     host.
                                     */
                                    requestVolume?: number;
                                    /**
                                     * Format: int32
                                     * @description The failure percentage to use when determining failure percentage-based
                                     *     outlier detection. If the failure percentage of a given host is greater
                                     *     than or equal to this value, it will be ejected.
                                     */
                                    threshold?: number;
                                };
                                /** @description In the default mode (outlierDetection.splitExternalLocalOriginErrors is
                                 *     false) this detection type takes into account a subset of 5xx errors,
                                 *     called "gateway errors" (502, 503 or 504 status code) and local origin
                                 *     failures, such as timeout, TCP reset etc.
                                 *     In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
                                 *     this detection type takes into account a subset of 5xx errors, called
                                 *     "gateway errors" (502, 503 or 504 status code) and is supported only by
                                 *     the http router. */
                                gatewayFailures?: {
                                    /**
                                     * Format: int32
                                     * @description The number of consecutive gateway failures (502, 503, 504 status codes)
                                     *     before a consecutive gateway failure ejection occurs.
                                     */
                                    consecutive?: number;
                                };
                                /** @description This detection type is enabled only when
                                 *     outlierDetection.splitExternalLocalOriginErrors is true and takes into
                                 *     account only locally originated errors (timeout, reset, etc).
                                 *     If Envoy repeatedly cannot connect to an upstream host or communication
                                 *     with the upstream host is repeatedly interrupted, it will be ejected.
                                 *     Various locally originated problems are detected: timeout, TCP reset,
                                 *     ICMP errors, etc. This detection type is supported by http router and
                                 *     tcp proxy. */
                                localOriginFailures?: {
                                    /**
                                     * Format: int32
                                     * @description The number of consecutive locally originated failures before ejection
                                     *     occurs. Parameter takes effect only when splitExternalAndLocalErrors
                                     *     is set to true.
                                     */
                                    consecutive?: number;
                                };
                                /** @description Success Rate based outlier detection aggregates success rate data from
                                 *     every host in a cluster. Then at given intervals ejects hosts based on
                                 *     statistical outlier detection. Success Rate outlier detection will not be
                                 *     calculated for a host if its request volume over the aggregation interval
                                 *     is less than the outlierDetection.detectors.successRate.requestVolume
                                 *     value.
                                 *     Moreover, detection will not be performed for a cluster if the number of
                                 *     hosts with the minimum required request volume in an interval is less
                                 *     than the outlierDetection.detectors.successRate.minimumHosts value.
                                 *     In the default configuration mode
                                 *     (outlierDetection.splitExternalLocalOriginErrors is false) this detection
                                 *     type takes into account all types of errors: locally and externally
                                 *     originated.
                                 *     In split mode (outlierDetection.splitExternalLocalOriginErrors is true),
                                 *     locally originated errors and externally originated (transaction) errors
                                 *     are counted and treated separately. */
                                successRate?: {
                                    /**
                                     * Format: int32
                                     * @description The number of hosts in a cluster that must have enough request volume to
                                     *     detect success rate outliers. If the number of hosts is less than this
                                     *     setting, outlier detection via success rate statistics is not performed
                                     *     for any host in the cluster.
                                     */
                                    minimumHosts?: number;
                                    /**
                                     * Format: int32
                                     * @description The minimum number of total requests that must be collected in one
                                     *     interval (as defined by the interval duration configured in
                                     *     outlierDetection section) to include this host in success rate based
                                     *     outlier detection. If the volume is lower than this setting, outlier
                                     *     detection via success rate statistics is not performed for that host.
                                     */
                                    requestVolume?: number;
                                    /** @description This factor is used to determine the ejection threshold for success rate
                                     *     outlier ejection. The ejection threshold is the difference between
                                     *     the mean success rate, and the product of this factor and the standard
                                     *     deviation of the mean success rate: mean - (standard_deviation *
                                     *     success_rate_standard_deviation_factor).
                                     *     Either int or decimal represented as string. */
                                    standardDeviationFactor?: number | string;
                                };
                                /** @description In the default mode (outlierDetection.splitExternalAndLocalErrors is
                                 *     false) this detection type takes into account all generated errors:
                                 *     locally originated and externally originated (transaction) errors.
                                 *     In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
                                 *     this detection type takes into account only externally originated
                                 *     (transaction) errors, ignoring locally originated errors.
                                 *     If an upstream host is an HTTP-server, only 5xx types of error are taken
                                 *     into account (see Consecutive Gateway Failure for exceptions).
                                 *     Properly formatted responses, even when they carry an operational error
                                 *     (like index not found, access denied) are not taken into account. */
                                totalFailures?: {
                                    /**
                                     * Format: int32
                                     * @description The number of consecutive server-side error responses (for HTTP traffic,
                                     *     5xx responses; for TCP traffic, connection failures; for Redis, failure
                                     *     to respond PONG; etc.) before a consecutive total failure ejection
                                     *     occurs.
                                     */
                                    consecutive?: number;
                                };
                            };
                            /** @description When set to true, outlierDetection configuration won't take any effect */
                            disabled?: boolean;
                            /** @description Allows to configure panic threshold for Envoy cluster. If not specified,
                             *     the default is 50%. To disable panic mode, set to 0%.
                             *     Either int or decimal represented as string. */
                            healthyPanicThreshold?: number | string;
                            /** @description The time interval between ejection analysis sweeps. This can result in
                             *     both new ejections and hosts being returned to service. */
                            interval?: string;
                            /**
                             * Format: int32
                             * @description The maximum % of an upstream cluster that can be ejected due to outlier
                             *     detection. Defaults to 10% but will eject at least one host regardless of
                             *     the value.
                             */
                            maxEjectionPercent?: number;
                            /** @description Determines whether to distinguish local origin failures from external
                             *     errors. If set to true the following configuration parameters are taken
                             *     into account: detectors.localOriginFailures.consecutive */
                            splitExternalAndLocalErrors?: boolean;
                        };
                    };
                }[];
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined in place. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
                /** @description To list makes a match between the consumed services and corresponding
                 *     configurations */
                to?: {
                    /** @description Default is a configuration specific to the group of destinations
                     *     referenced in 'targetRef' */
                    default?: {
                        /** @description ConnectionLimits contains configuration of each circuit breaking limit,
                         *     which when exceeded makes the circuit breaker to become open (no traffic
                         *     is allowed like no current is allowed in the circuits when physical
                         *     circuit breaker ir open) */
                        connectionLimits?: {
                            /**
                             * Format: int32
                             * @description The maximum number of connection pools per cluster that are concurrently
                             *     supported at once. Set this for clusters which create a large number of
                             *     connection pools.
                             */
                            maxConnectionPools?: number;
                            /**
                             * Format: int32
                             * @description The maximum number of connections allowed to be made to the upstream
                             *     cluster.
                             */
                            maxConnections?: number;
                            /**
                             * Format: int32
                             * @description The maximum number of pending requests that are allowed to the upstream
                             *     cluster. This limit is applied as a connection limit for non-HTTP
                             *     traffic.
                             */
                            maxPendingRequests?: number;
                            /**
                             * Format: int32
                             * @description The maximum number of parallel requests that are allowed to be made
                             *     to the upstream cluster. This limit does not apply to non-HTTP traffic.
                             */
                            maxRequests?: number;
                            /**
                             * Format: int32
                             * @description The maximum number of parallel retries that will be allowed to
                             *     the upstream cluster.
                             */
                            maxRetries?: number;
                        };
                        /** @description OutlierDetection contains the configuration of the process of dynamically
                         *     determining whether some number of hosts in an upstream cluster are
                         *     performing unlike the others and removing them from the healthy load
                         *     balancing set. Performance might be along different axes such as
                         *     consecutive failures, temporal success rate, temporal latency, etc.
                         *     Outlier detection is a form of passive health checking. */
                        outlierDetection?: {
                            /** @description The base time that a host is ejected for. The real time is equal to
                             *     the base time multiplied by the number of times the host has been
                             *     ejected. */
                            baseEjectionTime?: string;
                            /** @description Contains configuration for supported outlier detectors */
                            detectors?: {
                                /** @description Failure Percentage based outlier detection functions similarly to success
                                 *     rate detection, in that it relies on success rate data from each host in
                                 *     a cluster. However, rather than compare those values to the mean success
                                 *     rate of the cluster as a whole, they are compared to a flat
                                 *     user-configured threshold. This threshold is configured via the
                                 *     outlierDetection.failurePercentageThreshold field.
                                 *     The other configuration fields for failure percentage based detection are
                                 *     similar to the fields for success rate detection. As with success rate
                                 *     detection, detection will not be performed for a host if its request
                                 *     volume over the aggregation interval is less than the
                                 *     outlierDetection.detectors.failurePercentage.requestVolume value.
                                 *     Detection also will not be performed for a cluster if the number of hosts
                                 *     with the minimum required request volume in an interval is less than the
                                 *     outlierDetection.detectors.failurePercentage.minimumHosts value. */
                                failurePercentage?: {
                                    /**
                                     * Format: int32
                                     * @description The minimum number of hosts in a cluster in order to perform failure
                                     *     percentage-based ejection. If the total number of hosts in the cluster is
                                     *     less than this value, failure percentage-based ejection will not be
                                     *     performed.
                                     */
                                    minimumHosts?: number;
                                    /**
                                     * Format: int32
                                     * @description The minimum number of total requests that must be collected in one
                                     *     interval (as defined by the interval duration above) to perform failure
                                     *     percentage-based ejection for this host. If the volume is lower than this
                                     *     setting, failure percentage-based ejection will not be performed for this
                                     *     host.
                                     */
                                    requestVolume?: number;
                                    /**
                                     * Format: int32
                                     * @description The failure percentage to use when determining failure percentage-based
                                     *     outlier detection. If the failure percentage of a given host is greater
                                     *     than or equal to this value, it will be ejected.
                                     */
                                    threshold?: number;
                                };
                                /** @description In the default mode (outlierDetection.splitExternalLocalOriginErrors is
                                 *     false) this detection type takes into account a subset of 5xx errors,
                                 *     called "gateway errors" (502, 503 or 504 status code) and local origin
                                 *     failures, such as timeout, TCP reset etc.
                                 *     In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
                                 *     this detection type takes into account a subset of 5xx errors, called
                                 *     "gateway errors" (502, 503 or 504 status code) and is supported only by
                                 *     the http router. */
                                gatewayFailures?: {
                                    /**
                                     * Format: int32
                                     * @description The number of consecutive gateway failures (502, 503, 504 status codes)
                                     *     before a consecutive gateway failure ejection occurs.
                                     */
                                    consecutive?: number;
                                };
                                /** @description This detection type is enabled only when
                                 *     outlierDetection.splitExternalLocalOriginErrors is true and takes into
                                 *     account only locally originated errors (timeout, reset, etc).
                                 *     If Envoy repeatedly cannot connect to an upstream host or communication
                                 *     with the upstream host is repeatedly interrupted, it will be ejected.
                                 *     Various locally originated problems are detected: timeout, TCP reset,
                                 *     ICMP errors, etc. This detection type is supported by http router and
                                 *     tcp proxy. */
                                localOriginFailures?: {
                                    /**
                                     * Format: int32
                                     * @description The number of consecutive locally originated failures before ejection
                                     *     occurs. Parameter takes effect only when splitExternalAndLocalErrors
                                     *     is set to true.
                                     */
                                    consecutive?: number;
                                };
                                /** @description Success Rate based outlier detection aggregates success rate data from
                                 *     every host in a cluster. Then at given intervals ejects hosts based on
                                 *     statistical outlier detection. Success Rate outlier detection will not be
                                 *     calculated for a host if its request volume over the aggregation interval
                                 *     is less than the outlierDetection.detectors.successRate.requestVolume
                                 *     value.
                                 *     Moreover, detection will not be performed for a cluster if the number of
                                 *     hosts with the minimum required request volume in an interval is less
                                 *     than the outlierDetection.detectors.successRate.minimumHosts value.
                                 *     In the default configuration mode
                                 *     (outlierDetection.splitExternalLocalOriginErrors is false) this detection
                                 *     type takes into account all types of errors: locally and externally
                                 *     originated.
                                 *     In split mode (outlierDetection.splitExternalLocalOriginErrors is true),
                                 *     locally originated errors and externally originated (transaction) errors
                                 *     are counted and treated separately. */
                                successRate?: {
                                    /**
                                     * Format: int32
                                     * @description The number of hosts in a cluster that must have enough request volume to
                                     *     detect success rate outliers. If the number of hosts is less than this
                                     *     setting, outlier detection via success rate statistics is not performed
                                     *     for any host in the cluster.
                                     */
                                    minimumHosts?: number;
                                    /**
                                     * Format: int32
                                     * @description The minimum number of total requests that must be collected in one
                                     *     interval (as defined by the interval duration configured in
                                     *     outlierDetection section) to include this host in success rate based
                                     *     outlier detection. If the volume is lower than this setting, outlier
                                     *     detection via success rate statistics is not performed for that host.
                                     */
                                    requestVolume?: number;
                                    /** @description This factor is used to determine the ejection threshold for success rate
                                     *     outlier ejection. The ejection threshold is the difference between
                                     *     the mean success rate, and the product of this factor and the standard
                                     *     deviation of the mean success rate: mean - (standard_deviation *
                                     *     success_rate_standard_deviation_factor).
                                     *     Either int or decimal represented as string. */
                                    standardDeviationFactor?: number | string;
                                };
                                /** @description In the default mode (outlierDetection.splitExternalAndLocalErrors is
                                 *     false) this detection type takes into account all generated errors:
                                 *     locally originated and externally originated (transaction) errors.
                                 *     In split mode (outlierDetection.splitExternalLocalOriginErrors is true)
                                 *     this detection type takes into account only externally originated
                                 *     (transaction) errors, ignoring locally originated errors.
                                 *     If an upstream host is an HTTP-server, only 5xx types of error are taken
                                 *     into account (see Consecutive Gateway Failure for exceptions).
                                 *     Properly formatted responses, even when they carry an operational error
                                 *     (like index not found, access denied) are not taken into account. */
                                totalFailures?: {
                                    /**
                                     * Format: int32
                                     * @description The number of consecutive server-side error responses (for HTTP traffic,
                                     *     5xx responses; for TCP traffic, connection failures; for Redis, failure
                                     *     to respond PONG; etc.) before a consecutive total failure ejection
                                     *     occurs.
                                     */
                                    consecutive?: number;
                                };
                            };
                            /** @description When set to true, outlierDetection configuration won't take any effect */
                            disabled?: boolean;
                            /** @description Allows to configure panic threshold for Envoy cluster. If not specified,
                             *     the default is 50%. To disable panic mode, set to 0%.
                             *     Either int or decimal represented as string. */
                            healthyPanicThreshold?: number | string;
                            /** @description The time interval between ejection analysis sweeps. This can result in
                             *     both new ejections and hosts being returned to service. */
                            interval?: string;
                            /**
                             * Format: int32
                             * @description The maximum % of an upstream cluster that can be ejected due to outlier
                             *     detection. Defaults to 10% but will eject at least one host regardless of
                             *     the value.
                             */
                            maxEjectionPercent?: number;
                            /** @description Determines whether to distinguish local origin failures from external
                             *     errors. If set to true the following configuration parameters are taken
                             *     into account: detectors.localOriginFailures.consecutive */
                            splitExternalAndLocalErrors?: boolean;
                        };
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     destinations. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshCircuitBreakerCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshCircuitBreakerDeleteSuccessResponse: Record<string, never>;
        MeshFaultInjectionItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshFaultInjection";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshFaultInjection resource. */
            spec: {
                /** @description From list makes a match between clients and corresponding configurations */
                from?: {
                    /** @description Default is a configuration specific to the group of destinations referenced in
                     *     'targetRef' */
                    default?: {
                        /** @description Http allows to define list of Http faults between dataplanes. */
                        http?: {
                            /** @description Abort defines a configuration of not delivering requests to destination
                             *     service and replacing the responses from destination dataplane by
                             *     predefined status code */
                            abort?: {
                                /**
                                 * Format: int32
                                 * @description HTTP status code which will be returned to source side
                                 */
                                httpStatus: number;
                                /** @description Percentage of requests on which abort will be injected, has to be
                                 *     either int or decimal represented as string. */
                                percentage: number | string;
                            };
                            /** @description Delay defines configuration of delaying a response from a destination */
                            delay?: {
                                /** @description Percentage of requests on which delay will be injected, has to be
                                 *     either int or decimal represented as string. */
                                percentage: number | string;
                                /** @description The duration during which the response will be delayed */
                                value: string;
                            };
                            /** @description ResponseBandwidth defines a configuration to limit the speed of
                             *     responding to the requests */
                            responseBandwidth?: {
                                /** @description Limit is represented by value measure in Gbps, Mbps, kbps, e.g.
                                 *     10kbps */
                                limit: string;
                                /** @description Percentage of requests on which response bandwidth limit will be
                                 *     either int or decimal represented as string. */
                                percentage: number | string;
                            };
                        }[];
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     destinations. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined inplace. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
                /** @description To list makes a match between clients and corresponding configurations */
                to?: {
                    /** @description Default is a configuration specific to the group of destinations referenced in
                     *     'targetRef' */
                    default?: {
                        /** @description Http allows to define list of Http faults between dataplanes. */
                        http?: {
                            /** @description Abort defines a configuration of not delivering requests to destination
                             *     service and replacing the responses from destination dataplane by
                             *     predefined status code */
                            abort?: {
                                /**
                                 * Format: int32
                                 * @description HTTP status code which will be returned to source side
                                 */
                                httpStatus: number;
                                /** @description Percentage of requests on which abort will be injected, has to be
                                 *     either int or decimal represented as string. */
                                percentage: number | string;
                            };
                            /** @description Delay defines configuration of delaying a response from a destination */
                            delay?: {
                                /** @description Percentage of requests on which delay will be injected, has to be
                                 *     either int or decimal represented as string. */
                                percentage: number | string;
                                /** @description The duration during which the response will be delayed */
                                value: string;
                            };
                            /** @description ResponseBandwidth defines a configuration to limit the speed of
                             *     responding to the requests */
                            responseBandwidth?: {
                                /** @description Limit is represented by value measure in Gbps, Mbps, kbps, e.g.
                                 *     10kbps */
                                limit: string;
                                /** @description Percentage of requests on which response bandwidth limit will be
                                 *     either int or decimal represented as string. */
                                percentage: number | string;
                            };
                        }[];
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     destinations. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshFaultInjectionCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshFaultInjectionDeleteSuccessResponse: Record<string, never>;
        MeshHealthCheckItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshHealthCheck";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshHealthCheck resource. */
            spec: {
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined inplace. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
                /** @description To list makes a match between the consumed services and corresponding configurations */
                to?: {
                    /** @description Default is a configuration specific to the group of destinations referenced in
                     *     'targetRef' */
                    default?: {
                        /** @description If set to true, health check failure events will always be logged. If set
                         *     to false, only the initial health check failure event will be logged. The
                         *     default value is false. */
                        alwaysLogHealthCheckFailures?: boolean;
                        /** @description Specifies the path to the file where Envoy can log health check events.
                         *     If empty, no event log will be written. */
                        eventLogPath?: string;
                        /** @description If set to true, Envoy will not consider any hosts when the cluster is in
                         *     'panic mode'. Instead, the cluster will fail all requests as if all hosts
                         *     are unhealthy. This can help avoid potentially overwhelming a failing
                         *     service. */
                        failTrafficOnPanic?: boolean;
                        /** @description GrpcHealthCheck defines gRPC configuration which will instruct the service
                         *     the health check will be made for is a gRPC service. */
                        grpc?: {
                            /** @description The value of the :authority header in the gRPC health check request,
                             *     by default name of the cluster this health check is associated with */
                            authority?: string;
                            /** @description If true the GrpcHealthCheck is disabled */
                            disabled?: boolean;
                            /** @description Service name parameter which will be sent to gRPC service */
                            serviceName?: string;
                        };
                        /** @description Allows to configure panic threshold for Envoy cluster. If not specified,
                         *     the default is 50%. To disable panic mode, set to 0%.
                         *     Either int or decimal represented as string.
                         *     Deprecated: the setting has been moved to MeshCircuitBreaker policy,
                         *     please use MeshCircuitBreaker policy instead. */
                        healthyPanicThreshold?: number | string;
                        /**
                         * Format: int32
                         * @description Number of consecutive healthy checks before considering a host healthy.
                         *     If not specified then the default value is 1
                         */
                        healthyThreshold?: number;
                        /** @description HttpHealthCheck defines HTTP configuration which will instruct the service
                         *     the health check will be made for is an HTTP service. */
                        http?: {
                            /** @description If true the HttpHealthCheck is disabled */
                            disabled?: boolean;
                            /** @description List of HTTP response statuses which are considered healthy */
                            expectedStatuses?: number[];
                            /** @description The HTTP path which will be requested during the health check
                             *     (ie. /health)
                             *     If not specified then the default value is "/" */
                            path?: string;
                            /** @description The list of HTTP headers which should be added to each health check
                             *     request */
                            requestHeadersToAdd?: {
                                add?: {
                                    name: string;
                                    value: string;
                                }[];
                                set?: {
                                    name: string;
                                    value: string;
                                }[];
                            };
                        };
                        /** @description If specified, Envoy will start health checking after a random time in
                         *     ms between 0 and initialJitter. This only applies to the first health
                         *     check. */
                        initialJitter?: string;
                        /** @description Interval between consecutive health checks.
                         *     If not specified then the default value is 1m */
                        interval?: string;
                        /** @description If specified, during every interval Envoy will add IntervalJitter to the
                         *     wait time. */
                        intervalJitter?: string;
                        /**
                         * Format: int32
                         * @description If specified, during every interval Envoy will add IntervalJitter *
                         *     IntervalJitterPercent / 100 to the wait time. If IntervalJitter and
                         *     IntervalJitterPercent are both set, both of them will be used to
                         *     increase the wait time.
                         */
                        intervalJitterPercent?: number;
                        /** @description The "no traffic interval" is a special health check interval that is used
                         *     when a cluster has never had traffic routed to it. This lower interval
                         *     allows cluster information to be kept up to date, without sending a
                         *     potentially large amount of active health checking traffic for no reason.
                         *     Once a cluster has been used for traffic routing, Envoy will shift back
                         *     to using the standard health check interval that is defined. Note that
                         *     this interval takes precedence over any other. The default value for "no
                         *     traffic interval" is 60 seconds. */
                        noTrafficInterval?: string;
                        /** @description Reuse health check connection between health checks. Default is true. */
                        reuseConnection?: boolean;
                        /** @description TcpHealthCheck defines configuration for specifying bytes to send and
                         *     expected response during the health check */
                        tcp?: {
                            /** @description If true the TcpHealthCheck is disabled */
                            disabled?: boolean;
                            /** @description List of Base64 encoded blocks of strings expected as a response. When checking the response,
                             *     "fuzzy" matching is performed such that each block must be found, and
                             *     in the order specified, but not necessarily contiguous.
                             *     If not provided or empty, checks will be performed as "connect only" and be marked as successful when TCP connection is successfully established. */
                            receive?: string[];
                            /** @description Base64 encoded content of the message which will be sent during the health check to the target */
                            send?: string;
                        };
                        /** @description Maximum time to wait for a health check response.
                         *     If not specified then the default value is 15s */
                        timeout?: string;
                        /**
                         * Format: int32
                         * @description Number of consecutive unhealthy checks before considering a host
                         *     unhealthy.
                         *     If not specified then the default value is 5
                         */
                        unhealthyThreshold?: number;
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     destinations. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshHealthCheckCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshHealthCheckDeleteSuccessResponse: Record<string, never>;
        MeshHTTPRouteItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshHTTPRoute";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshHTTPRoute resource. */
            spec: {
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined inplace. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
                /** @description To matches destination services of requests and holds configuration. */
                to?: {
                    /** @description Hostnames is only valid when targeting MeshGateway and limits the
                     *     effects of the rules to requests to this hostname.
                     *     Given hostnames must intersect with the hostname of the listeners the
                     *     route attaches to. */
                    hostnames?: string[];
                    /** @description Rules contains the routing rules applies to a combination of top-level
                     *     targetRef and the targetRef in this entry. */
                    rules: {
                        /** @description Default holds routing rules that can be merged with rules from other
                         *     policies. */
                        default: {
                            backendRefs?: {
                                /**
                                 * @description Kind of the referenced resource
                                 * @enum {string}
                                 */
                                kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                                /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                                 *     Name and Namespace can be used. */
                                labels?: {
                                    [key: string]: string;
                                };
                                /** @description Mesh is reserved for future use to identify cross mesh resources. */
                                mesh?: string;
                                /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                                 *     `MeshServiceSubset` and `MeshGatewayRoute` */
                                name?: string;
                                /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                                 *     will be targeted. */
                                namespace?: string;
                                /**
                                 * Format: int32
                                 * @description Port is only supported when this ref refers to a real MeshService object
                                 */
                                port?: number;
                                /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                                 *     all data plane types are targeted by the policy. */
                                proxyTypes?: ("Sidecar" | "Gateway")[];
                                /** @description SectionName is used to target specific section of resource.
                                 *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                                sectionName?: string;
                                /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                                 *     `MeshSubset` and `MeshServiceSubset` */
                                tags?: {
                                    [key: string]: string;
                                };
                                /** @default 1 */
                                weight: number;
                            }[];
                            filters?: {
                                /** @description Only one action is supported per header name.
                                 *     Configuration to set or add multiple values for a header must use RFC 7230
                                 *     header value formatting, separating each value with a comma. */
                                requestHeaderModifier?: {
                                    add?: {
                                        name: string;
                                        value: string;
                                    }[];
                                    remove?: string[];
                                    set?: {
                                        name: string;
                                        value: string;
                                    }[];
                                };
                                requestMirror?: {
                                    /** @description BackendRef defines where to forward traffic. */
                                    backendRef: {
                                        /**
                                         * @description Kind of the referenced resource
                                         * @enum {string}
                                         */
                                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                                         *     Name and Namespace can be used. */
                                        labels?: {
                                            [key: string]: string;
                                        };
                                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                                        mesh?: string;
                                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                                        name?: string;
                                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                                         *     will be targeted. */
                                        namespace?: string;
                                        /**
                                         * Format: int32
                                         * @description Port is only supported when this ref refers to a real MeshService object
                                         */
                                        port?: number;
                                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                                         *     all data plane types are targeted by the policy. */
                                        proxyTypes?: ("Sidecar" | "Gateway")[];
                                        /** @description SectionName is used to target specific section of resource.
                                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                                        sectionName?: string;
                                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                                         *     `MeshSubset` and `MeshServiceSubset` */
                                        tags?: {
                                            [key: string]: string;
                                        };
                                        /** @default 1 */
                                        weight: number;
                                    };
                                    /** @description Percentage of requests to mirror. If not specified, all requests
                                     *     to the target cluster will be mirrored. */
                                    percentage?: number | string;
                                };
                                requestRedirect?: {
                                    /** @description PreciseHostname is the fully qualified domain name of a network host. This
                                     *     matches the RFC 1123 definition of a hostname with 1 notable exception that
                                     *     numeric IP addresses are not allowed.
                                     *
                                     *     Note that as per RFC1035 and RFC1123, a *label* must consist of lower case
                                     *     alphanumeric characters or '-', and must start and end with an alphanumeric
                                     *     character. No other punctuation is allowed. */
                                    hostname?: string;
                                    /** @description Path defines parameters used to modify the path of the incoming request.
                                     *     The modified path is then used to construct the location header.
                                     *     When empty, the request path is used as-is. */
                                    path?: {
                                        replaceFullPath?: string;
                                        replacePrefixMatch?: string;
                                        /** @enum {string} */
                                        type: "ReplaceFullPath" | "ReplacePrefixMatch";
                                    };
                                    /**
                                     * Format: int32
                                     * @description Port is the port to be used in the value of the `Location`
                                     *     header in the response.
                                     *     When empty, port (if specified) of the request is used.
                                     */
                                    port?: number;
                                    /** @enum {string} */
                                    scheme?: "http" | "https";
                                    /**
                                     * @description StatusCode is the HTTP status code to be used in response.
                                     * @default 302
                                     * @enum {integer}
                                     */
                                    statusCode: 301 | 302 | 303 | 307 | 308;
                                };
                                /** @description Only one action is supported per header name.
                                 *     Configuration to set or add multiple values for a header must use RFC 7230
                                 *     header value formatting, separating each value with a comma. */
                                responseHeaderModifier?: {
                                    add?: {
                                        name: string;
                                        value: string;
                                    }[];
                                    remove?: string[];
                                    set?: {
                                        name: string;
                                        value: string;
                                    }[];
                                };
                                /** @enum {string} */
                                type: "RequestHeaderModifier" | "ResponseHeaderModifier" | "RequestRedirect" | "URLRewrite" | "RequestMirror";
                                urlRewrite?: {
                                    /** @description HostToBackendHostname rewrites the hostname to the hostname of the
                                     *     upstream host. This option is only available when targeting MeshGateways. */
                                    hostToBackendHostname?: boolean;
                                    /** @description Hostname is the value to be used to replace the host header value during forwarding. */
                                    hostname?: string;
                                    /** @description Path defines a path rewrite. */
                                    path?: {
                                        replaceFullPath?: string;
                                        replacePrefixMatch?: string;
                                        /** @enum {string} */
                                        type: "ReplaceFullPath" | "ReplacePrefixMatch";
                                    };
                                };
                            }[];
                        };
                        /** @description Matches describes how to match HTTP requests this rule should be applied
                         *     to. */
                        matches: {
                            headers?: {
                                /** @description Name is the name of the HTTP Header to be matched. Name MUST be lower case
                                 *     as they will be handled with case insensitivity (See https://tools.ietf.org/html/rfc7230#section-3.2). */
                                name: string;
                                /**
                                 * @description Type specifies how to match against the value of the header.
                                 * @default Exact
                                 * @enum {string}
                                 */
                                type: "Exact" | "Present" | "RegularExpression" | "Absent" | "Prefix";
                                /** @description Value is the value of HTTP Header to be matched. */
                                value?: string;
                            }[];
                            /** @enum {string} */
                            method?: "CONNECT" | "DELETE" | "GET" | "HEAD" | "OPTIONS" | "PATCH" | "POST" | "PUT" | "TRACE";
                            path?: {
                                /** @enum {string} */
                                type: "Exact" | "PathPrefix" | "RegularExpression";
                                /** @description Exact or prefix matches must be an absolute path. A prefix matches only
                                 *     if separated by a slash or the entire path. */
                                value: string;
                            };
                            /** @description QueryParams matches based on HTTP URL query parameters. Multiple matches
                             *     are ANDed together such that all listed matches must succeed. */
                            queryParams?: {
                                name: string;
                                /** @enum {string} */
                                type: "Exact" | "RegularExpression";
                                value: string;
                            }[];
                        }[];
                    }[];
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     request destinations. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshHTTPRouteCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshHTTPRouteDeleteSuccessResponse: Record<string, never>;
        MeshLoadBalancingStrategyItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshLoadBalancingStrategy";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshLoadBalancingStrategy resource. */
            spec: {
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined inplace. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
                /** @description To list makes a match between the consumed services and corresponding configurations */
                to?: {
                    /** @description Default is a configuration specific to the group of destinations referenced in
                     *     'targetRef' */
                    default?: {
                        /** @description HashPolicies specify a list of request/connection properties that are used to calculate a hash.
                         *     These hash policies are executed in the specified order. If a hash policy has the “terminal” attribute
                         *     set to true, and there is already a hash generated, the hash is returned immediately,
                         *     ignoring the rest of the hash policy list. */
                        hashPolicies?: {
                            connection?: {
                                /** @description Hash on source IP address. */
                                sourceIP?: boolean;
                            };
                            cookie?: {
                                /** @description The name of the cookie that will be used to obtain the hash key. */
                                name: string;
                                /** @description The name of the path for the cookie. */
                                path?: string;
                                /** @description If specified, a cookie with the TTL will be generated if the cookie is not present. */
                                ttl?: string;
                            };
                            filterState?: {
                                /** @description The name of the Object in the per-request filterState, which is
                                 *     an Envoy::Hashable object. If there is no data associated with the key,
                                 *     or the stored object is not Envoy::Hashable, no hash will be produced. */
                                key: string;
                            };
                            header?: {
                                /** @description The name of the request header that will be used to obtain the hash key. */
                                name: string;
                            };
                            queryParameter?: {
                                /** @description The name of the URL query parameter that will be used to obtain the hash key.
                                 *     If the parameter is not present, no hash will be produced. Query parameter names
                                 *     are case-sensitive. */
                                name: string;
                            };
                            /** @description Terminal is a flag that short-circuits the hash computing. This field provides
                             *     a ‘fallback’ style of configuration: “if a terminal policy doesn’t work, fallback
                             *     to rest of the policy list”, it saves time when the terminal policy works.
                             *     If true, and there is already a hash computed, ignore rest of the list of hash polices. */
                            terminal?: boolean;
                            /** @enum {string} */
                            type: "Header" | "Cookie" | "Connection" | "SourceIP" | "QueryParameter" | "FilterState";
                        }[];
                        /** @description LoadBalancer allows to specify load balancing algorithm. */
                        loadBalancer?: {
                            /** @description LeastRequest selects N random available hosts as specified in 'choiceCount' (2 by default)
                             *     and picks the host which has the fewest active requests */
                            leastRequest?: {
                                /** @description ActiveRequestBias refers to dynamic weights applied when hosts have varying load
                                 *     balancing weights. A higher value here aggressively reduces the weight of endpoints
                                 *     that are currently handling active requests. In essence, the higher the ActiveRequestBias
                                 *     value, the more forcefully it reduces the load balancing weight of endpoints that are
                                 *     actively serving requests. */
                                activeRequestBias?: number | string;
                                /**
                                 * Format: int32
                                 * @description ChoiceCount is the number of random healthy hosts from which the host with
                                 *     the fewest active requests will be chosen. Defaults to 2 so that Envoy performs
                                 *     two-choice selection if the field is not set.
                                 */
                                choiceCount?: number;
                            };
                            /** @description Maglev implements consistent hashing to upstream hosts. Maglev can be used as
                             *     a drop in replacement for the ring hash load balancer any place in which
                             *     consistent hashing is desired. */
                            maglev?: {
                                /** @description HashPolicies specify a list of request/connection properties that are used to calculate a hash.
                                 *     These hash policies are executed in the specified order. If a hash policy has the “terminal” attribute
                                 *     set to true, and there is already a hash generated, the hash is returned immediately,
                                 *     ignoring the rest of the hash policy list. */
                                hashPolicies?: {
                                    connection?: {
                                        /** @description Hash on source IP address. */
                                        sourceIP?: boolean;
                                    };
                                    cookie?: {
                                        /** @description The name of the cookie that will be used to obtain the hash key. */
                                        name: string;
                                        /** @description The name of the path for the cookie. */
                                        path?: string;
                                        /** @description If specified, a cookie with the TTL will be generated if the cookie is not present. */
                                        ttl?: string;
                                    };
                                    filterState?: {
                                        /** @description The name of the Object in the per-request filterState, which is
                                         *     an Envoy::Hashable object. If there is no data associated with the key,
                                         *     or the stored object is not Envoy::Hashable, no hash will be produced. */
                                        key: string;
                                    };
                                    header?: {
                                        /** @description The name of the request header that will be used to obtain the hash key. */
                                        name: string;
                                    };
                                    queryParameter?: {
                                        /** @description The name of the URL query parameter that will be used to obtain the hash key.
                                         *     If the parameter is not present, no hash will be produced. Query parameter names
                                         *     are case-sensitive. */
                                        name: string;
                                    };
                                    /** @description Terminal is a flag that short-circuits the hash computing. This field provides
                                     *     a ‘fallback’ style of configuration: “if a terminal policy doesn’t work, fallback
                                     *     to rest of the policy list”, it saves time when the terminal policy works.
                                     *     If true, and there is already a hash computed, ignore rest of the list of hash polices. */
                                    terminal?: boolean;
                                    /** @enum {string} */
                                    type: "Header" | "Cookie" | "Connection" | "SourceIP" | "QueryParameter" | "FilterState";
                                }[];
                                /**
                                 * Format: int32
                                 * @description The table size for Maglev hashing. Maglev aims for “minimal disruption”
                                 *     rather than an absolute guarantee. Minimal disruption means that when
                                 *     the set of upstream hosts change, a connection will likely be sent
                                 *     to the same upstream as it was before. Increasing the table size reduces
                                 *     the amount of disruption. The table size must be prime number limited to 5000011.
                                 *     If it is not specified, the default is 65537.
                                 */
                                tableSize?: number;
                            };
                            /** @description Random selects a random available host. The random load balancer generally
                             *     performs better than round-robin if no health checking policy is configured.
                             *     Random selection avoids bias towards the host in the set that comes after a failed host. */
                            random?: Record<string, never>;
                            /** @description RingHash  implements consistent hashing to upstream hosts. Each host is mapped
                             *     onto a circle (the “ring”) by hashing its address; each request is then routed
                             *     to a host by hashing some property of the request, and finding the nearest
                             *     corresponding host clockwise around the ring. */
                            ringHash?: {
                                /**
                                 * @description HashFunction is a function used to hash hosts onto the ketama ring.
                                 *     The value defaults to XX_HASH. Available values – XX_HASH, MURMUR_HASH_2.
                                 * @enum {string}
                                 */
                                hashFunction?: "XXHash" | "MurmurHash2";
                                /** @description HashPolicies specify a list of request/connection properties that are used to calculate a hash.
                                 *     These hash policies are executed in the specified order. If a hash policy has the “terminal” attribute
                                 *     set to true, and there is already a hash generated, the hash is returned immediately,
                                 *     ignoring the rest of the hash policy list. */
                                hashPolicies?: {
                                    connection?: {
                                        /** @description Hash on source IP address. */
                                        sourceIP?: boolean;
                                    };
                                    cookie?: {
                                        /** @description The name of the cookie that will be used to obtain the hash key. */
                                        name: string;
                                        /** @description The name of the path for the cookie. */
                                        path?: string;
                                        /** @description If specified, a cookie with the TTL will be generated if the cookie is not present. */
                                        ttl?: string;
                                    };
                                    filterState?: {
                                        /** @description The name of the Object in the per-request filterState, which is
                                         *     an Envoy::Hashable object. If there is no data associated with the key,
                                         *     or the stored object is not Envoy::Hashable, no hash will be produced. */
                                        key: string;
                                    };
                                    header?: {
                                        /** @description The name of the request header that will be used to obtain the hash key. */
                                        name: string;
                                    };
                                    queryParameter?: {
                                        /** @description The name of the URL query parameter that will be used to obtain the hash key.
                                         *     If the parameter is not present, no hash will be produced. Query parameter names
                                         *     are case-sensitive. */
                                        name: string;
                                    };
                                    /** @description Terminal is a flag that short-circuits the hash computing. This field provides
                                     *     a ‘fallback’ style of configuration: “if a terminal policy doesn’t work, fallback
                                     *     to rest of the policy list”, it saves time when the terminal policy works.
                                     *     If true, and there is already a hash computed, ignore rest of the list of hash polices. */
                                    terminal?: boolean;
                                    /** @enum {string} */
                                    type: "Header" | "Cookie" | "Connection" | "SourceIP" | "QueryParameter" | "FilterState";
                                }[];
                                /**
                                 * Format: int32
                                 * @description Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries,
                                 *     but can be lowered to further constrain resource use.
                                 */
                                maxRingSize?: number;
                                /**
                                 * Format: int32
                                 * @description Minimum hash ring size. The larger the ring is (that is,
                                 *     the more hashes there are for each provided host) the better the request distribution
                                 *     will reflect the desired weights. Defaults to 1024 entries, and limited to 8M entries.
                                 */
                                minRingSize?: number;
                            };
                            /** @description RoundRobin is a load balancing algorithm that distributes requests
                             *     across available upstream hosts in round-robin order. */
                            roundRobin?: Record<string, never>;
                            /** @enum {string} */
                            type: "RoundRobin" | "LeastRequest" | "RingHash" | "Random" | "Maglev";
                        };
                        /** @description LocalityAwareness contains configuration for locality aware load balancing. */
                        localityAwareness?: {
                            /** @description CrossZone defines locality aware load balancing priorities when dataplane proxies inside local zone
                             *     are unavailable */
                            crossZone?: {
                                /** @description Failover defines list of load balancing rules in order of priority */
                                failover?: {
                                    /** @description From defines the list of zones to which the rule applies */
                                    from?: {
                                        zones: string[];
                                    };
                                    /** @description To defines to which zones the traffic should be load balanced */
                                    to: {
                                        /**
                                         * @description Type defines how target zones will be picked from available zones
                                         * @enum {string}
                                         */
                                        type: "None" | "Only" | "Any" | "AnyExcept";
                                        zones?: string[];
                                    };
                                }[];
                                /** @description FailoverThreshold defines the percentage of live destination dataplane proxies below which load balancing to the
                                 *     next priority starts.
                                 *     Example: If you configure failoverThreshold to 70, and you have deployed 10 destination dataplane proxies.
                                 *     Load balancing to next priority will start when number of live destination dataplane proxies drops below 7.
                                 *     Default 50 */
                                failoverThreshold?: {
                                    percentage: number | string;
                                };
                            };
                            /** @description Disabled allows to disable locality-aware load balancing.
                             *     When disabled requests are distributed across all endpoints regardless of locality. */
                            disabled?: boolean;
                            /** @description LocalZone defines locality aware load balancing priorities between dataplane proxies inside a zone */
                            localZone?: {
                                /** @description AffinityTags list of tags for local zone load balancing. */
                                affinityTags?: {
                                    /** @description Key defines tag for which affinity is configured */
                                    key: string;
                                    /**
                                     * Format: int32
                                     * @description Weight of the tag used for load balancing. The bigger the weight the bigger the priority.
                                     *     Percentage of local traffic load balanced to tag is computed by dividing weight by sum of weights from all tags.
                                     *     For example with two affinity tags first with weight 80 and second with weight 20,
                                     *     then 80% of traffic will be redirected to the first tag, and 20% of traffic will be redirected to second one.
                                     *     Setting weights is not mandatory. When weights are not set control plane will compute default weight based on list order.
                                     *     Default: If you do not specify weight we will adjust them so that 90% traffic goes to first tag, 9% to next, and 1% to third and so on.
                                     */
                                    weight?: number;
                                }[];
                            };
                        };
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     destinations. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshLoadBalancingStrategyCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshLoadBalancingStrategyDeleteSuccessResponse: Record<string, never>;
        MeshMetricItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshMetric";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshMetric resource. */
            spec: {
                /** @description MeshMetric configuration. */
                default?: {
                    /** @description Applications is a list of application that Dataplane Proxy will scrape */
                    applications?: {
                        /** @description Address on which an application listens. */
                        address?: string;
                        /** @description Name of the application to scrape */
                        name?: string;
                        /**
                         * @description Path on which an application expose HTTP endpoint with metrics.
                         * @default /metrics
                         */
                        path: string;
                        /**
                         * Format: int32
                         * @description Port on which an application expose HTTP endpoint with metrics.
                         */
                        port: number;
                    }[];
                    /** @description Backends list that will be used to collect metrics. */
                    backends?: {
                        /** @description OpenTelemetry backend configuration */
                        openTelemetry?: {
                            /** @description Endpoint for OpenTelemetry collector */
                            endpoint: string;
                            /** @description RefreshInterval defines how frequent metrics should be pushed to collector */
                            refreshInterval?: string;
                        };
                        /** @description Prometheus backend configuration. */
                        prometheus?: {
                            /** @description ClientId of the Prometheus backend. Needed when using MADS for DP discovery. */
                            clientId?: string;
                            /**
                             * @description Path on which a dataplane should expose HTTP endpoint with Prometheus metrics.
                             * @default /metrics
                             */
                            path: string;
                            /**
                             * Format: int32
                             * @description Port on which a dataplane should expose HTTP endpoint with Prometheus metrics.
                             * @default 5670
                             */
                            port: number;
                            /** @description Configuration of TLS for prometheus listener. */
                            tls?: {
                                /**
                                 * @description Configuration of TLS for Prometheus listener.
                                 * @default Disabled
                                 * @enum {string}
                                 */
                                mode: "Disabled" | "ProvidedTLS" | "ActiveMTLSBackend";
                            };
                        };
                        /**
                         * @description Type of the backend that will be used to collect metrics. At the moment only Prometheus backend is available.
                         * @enum {string}
                         */
                        type: "Prometheus" | "OpenTelemetry";
                    }[];
                    /** @description Sidecar metrics collection configuration */
                    sidecar?: {
                        /** @description IncludeUnused if false will scrape only metrics that has been by sidecar (counters incremented
                         *     at least once, gauges changed at least once, and histograms added to at
                         *     least once). If true will scrape all metrics (even the ones with zeros).
                         *     If not specified then the default value is false. */
                        includeUnused?: boolean;
                        /** @description Profiles allows to customize which metrics are published. */
                        profiles?: {
                            /** @description AppendProfiles allows to combine the metrics from multiple predefined profiles. */
                            appendProfiles?: {
                                /**
                                 * @description Name of the predefined profile, one of: all, basic, none
                                 * @enum {string}
                                 */
                                name: "All" | "Basic" | "None";
                            }[];
                            /** @description Exclude makes it possible to exclude groups of metrics from a resulting profile.
                             *     Exclude is subordinate to Include. */
                            exclude?: {
                                /** @description Match is the value used to match using particular Type */
                                match: string;
                                /**
                                 * @description Type defined the type of selector, one of: prefix, regex, exact
                                 * @enum {string}
                                 */
                                type: "Prefix" | "Regex" | "Exact" | "Contains";
                            }[];
                            /** @description Include makes it possible to include additional metrics in a selected profiles.
                             *     Include takes precedence over Exclude. */
                            include?: {
                                /** @description Match is the value used to match using particular Type */
                                match: string;
                                /**
                                 * @description Type defined the type of selector, one of: prefix, regex, exact
                                 * @enum {string}
                                 */
                                type: "Prefix" | "Regex" | "Exact" | "Contains";
                            }[];
                        };
                    };
                };
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined in-place. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshMetricCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshMetricDeleteSuccessResponse: Record<string, never>;
        MeshPassthroughItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshPassthrough";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshPassthrough resource. */
            spec: {
                /** @description MeshPassthrough configuration. */
                default?: {
                    /** @description AppendMatch is a list of destinations that should be allowed through the sidecar. */
                    appendMatch?: {
                        /**
                         * Format: int32
                         * @description Port defines the port to which a user makes a request.
                         */
                        port?: number;
                        /**
                         * @description Protocol defines the communication protocol. Possible values: `tcp`, `tls`, `grpc`, `http`, `http2`, `mysql`.
                         * @default tcp
                         * @enum {string}
                         */
                        protocol: "tcp" | "tls" | "grpc" | "http" | "http2" | "mysql";
                        /**
                         * @description Type of the match, one of `Domain`, `IP` or `CIDR` is available.
                         * @enum {string}
                         */
                        type: "Domain" | "IP" | "CIDR";
                        /** @description Value for the specified Type. */
                        value: string;
                    }[];
                    /**
                     * @description Defines the passthrough behavior. Possible values: `All`, `None`, `Matched`
                     *     When `All` or `None` `appendMatch` has no effect.
                     *     If not specified then the default value is "Matched".
                     * @enum {string}
                     */
                    passthroughMode?: "All" | "Matched" | "None";
                };
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined in-place. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshPassthroughCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshPassthroughDeleteSuccessResponse: Record<string, never>;
        MeshProxyPatchItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshProxyPatch";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshProxyPatch resource. */
            spec: {
                /** @description Default is a configuration specific to the group of destinations
                 *     referenced in 'targetRef'. */
                default: {
                    /** @description AppendModifications is a list of modifications applied on the selected proxy. */
                    appendModifications?: {
                        /** @description Cluster is a modification of Envoy's Cluster resource. */
                        cluster?: {
                            /** @description JsonPatches specifies list of jsonpatches to apply to on Envoy's Cluster
                             *     resource */
                            jsonPatches?: {
                                /** @description From is a jsonpatch from string, used by move and copy operations. */
                                from?: string;
                                /**
                                 * @description Op is a jsonpatch operation string.
                                 * @enum {string}
                                 */
                                op: "add" | "remove" | "replace" | "move" | "copy";
                                /** @description Path is a jsonpatch path string. */
                                path: string;
                                /** @description Value must be a valid json value used by replace and add operations. */
                                value?: unknown;
                            }[];
                            /** @description Match is a set of conditions that have to be matched for modification operation to happen. */
                            match?: {
                                /** @description Name of the cluster to match. */
                                name?: string;
                                /** @description Origin is the name of the component or plugin that generated the resource.
                                 *
                                 *     Here is the list of well-known origins:
                                 *     inbound - resources generated for handling incoming traffic.
                                 *     outbound - resources generated for handling outgoing traffic.
                                 *     transparent - resources generated for transparent proxy functionality.
                                 *     prometheus - resources generated when Prometheus metrics are enabled.
                                 *     direct-access - resources generated for Direct Access functionality.
                                 *     ingress - resources generated for Zone Ingress.
                                 *     egress - resources generated for Zone Egress.
                                 *     gateway - resources generated for MeshGateway.
                                 *
                                 *     The list is not complete, because policy plugins can introduce new resources.
                                 *     For example MeshTrace plugin can create Cluster with "mesh-trace" origin. */
                                origin?: string;
                            };
                            /**
                             * @description Operation to execute on matched cluster.
                             * @enum {string}
                             */
                            operation: "Add" | "Remove" | "Patch";
                            /** @description Value of xDS resource in YAML format to add or patch. */
                            value?: string;
                        };
                        /** @description HTTPFilter is a modification of Envoy HTTP Filter
                         *     available in HTTP Connection Manager in a Listener resource. */
                        httpFilter?: {
                            /** @description JsonPatches specifies list of jsonpatches to apply to on Envoy's
                             *     HTTP Filter available in HTTP Connection Manager in a Listener resource. */
                            jsonPatches?: {
                                /** @description From is a jsonpatch from string, used by move and copy operations. */
                                from?: string;
                                /**
                                 * @description Op is a jsonpatch operation string.
                                 * @enum {string}
                                 */
                                op: "add" | "remove" | "replace" | "move" | "copy";
                                /** @description Path is a jsonpatch path string. */
                                path: string;
                                /** @description Value must be a valid json value used by replace and add operations. */
                                value?: unknown;
                            }[];
                            /** @description Match is a set of conditions that have to be matched for modification operation to happen. */
                            match?: {
                                /** @description Name of the listener to match. */
                                listenerName?: string;
                                /** @description Listener tags available in Listener#Metadata#FilterMetadata[io.kuma.tags] */
                                listenerTags?: {
                                    [key: string]: string;
                                };
                                /** @description Name of the HTTP filter. For example "envoy.filters.http.local_ratelimit" */
                                name?: string;
                                /** @description Origin is the name of the component or plugin that generated the resource.
                                 *
                                 *     Here is the list of well-known origins:
                                 *     inbound - resources generated for handling incoming traffic.
                                 *     outbound - resources generated for handling outgoing traffic.
                                 *     transparent - resources generated for transparent proxy functionality.
                                 *     prometheus - resources generated when Prometheus metrics are enabled.
                                 *     direct-access - resources generated for Direct Access functionality.
                                 *     ingress - resources generated for Zone Ingress.
                                 *     egress - resources generated for Zone Egress.
                                 *     gateway - resources generated for MeshGateway.
                                 *
                                 *     The list is not complete, because policy plugins can introduce new resources.
                                 *     For example MeshTrace plugin can create Cluster with "mesh-trace" origin. */
                                origin?: string;
                            };
                            /**
                             * @description Operation to execute on matched listener.
                             * @enum {string}
                             */
                            operation: "Remove" | "Patch" | "AddFirst" | "AddBefore" | "AddAfter" | "AddLast";
                            /** @description Value of xDS resource in YAML format to add or patch. */
                            value?: string;
                        };
                        /** @description Listener is a modification of Envoy's Listener resource. */
                        listener?: {
                            /** @description JsonPatches specifies list of jsonpatches to apply to on Envoy's Listener
                             *     resource */
                            jsonPatches?: {
                                /** @description From is a jsonpatch from string, used by move and copy operations. */
                                from?: string;
                                /**
                                 * @description Op is a jsonpatch operation string.
                                 * @enum {string}
                                 */
                                op: "add" | "remove" | "replace" | "move" | "copy";
                                /** @description Path is a jsonpatch path string. */
                                path: string;
                                /** @description Value must be a valid json value used by replace and add operations. */
                                value?: unknown;
                            }[];
                            /** @description Match is a set of conditions that have to be matched for modification operation to happen. */
                            match?: {
                                /** @description Name of the listener to match. */
                                name?: string;
                                /** @description Origin is the name of the component or plugin that generated the resource.
                                 *
                                 *     Here is the list of well-known origins:
                                 *     inbound - resources generated for handling incoming traffic.
                                 *     outbound - resources generated for handling outgoing traffic.
                                 *     transparent - resources generated for transparent proxy functionality.
                                 *     prometheus - resources generated when Prometheus metrics are enabled.
                                 *     direct-access - resources generated for Direct Access functionality.
                                 *     ingress - resources generated for Zone Ingress.
                                 *     egress - resources generated for Zone Egress.
                                 *     gateway - resources generated for MeshGateway.
                                 *
                                 *     The list is not complete, because policy plugins can introduce new resources.
                                 *     For example MeshTrace plugin can create Cluster with "mesh-trace" origin. */
                                origin?: string;
                                /** @description Tags available in Listener#Metadata#FilterMetadata[io.kuma.tags] */
                                tags?: {
                                    [key: string]: string;
                                };
                            };
                            /**
                             * @description Operation to execute on matched listener.
                             * @enum {string}
                             */
                            operation: "Add" | "Remove" | "Patch";
                            /** @description Value of xDS resource in YAML format to add or patch. */
                            value?: string;
                        };
                        /** @description NetworkFilter is a modification of Envoy Listener's filter. */
                        networkFilter?: {
                            /** @description JsonPatches specifies list of jsonpatches to apply to on Envoy Listener's
                             *     filter. */
                            jsonPatches?: {
                                /** @description From is a jsonpatch from string, used by move and copy operations. */
                                from?: string;
                                /**
                                 * @description Op is a jsonpatch operation string.
                                 * @enum {string}
                                 */
                                op: "add" | "remove" | "replace" | "move" | "copy";
                                /** @description Path is a jsonpatch path string. */
                                path: string;
                                /** @description Value must be a valid json value used by replace and add operations. */
                                value?: unknown;
                            }[];
                            /** @description Match is a set of conditions that have to be matched for modification operation to happen. */
                            match?: {
                                /** @description Name of the listener to match. */
                                listenerName?: string;
                                /** @description Listener tags available in Listener#Metadata#FilterMetadata[io.kuma.tags] */
                                listenerTags?: {
                                    [key: string]: string;
                                };
                                /** @description Name of the network filter. For example "envoy.filters.network.ratelimit" */
                                name?: string;
                                /** @description Origin is the name of the component or plugin that generated the resource.
                                 *
                                 *     Here is the list of well-known origins:
                                 *     inbound - resources generated for handling incoming traffic.
                                 *     outbound - resources generated for handling outgoing traffic.
                                 *     transparent - resources generated for transparent proxy functionality.
                                 *     prometheus - resources generated when Prometheus metrics are enabled.
                                 *     direct-access - resources generated for Direct Access functionality.
                                 *     ingress - resources generated for Zone Ingress.
                                 *     egress - resources generated for Zone Egress.
                                 *     gateway - resources generated for MeshGateway.
                                 *
                                 *     The list is not complete, because policy plugins can introduce new resources.
                                 *     For example MeshTrace plugin can create Cluster with "mesh-trace" origin. */
                                origin?: string;
                            };
                            /**
                             * @description Operation to execute on matched listener.
                             * @enum {string}
                             */
                            operation: "Remove" | "Patch" | "AddFirst" | "AddBefore" | "AddAfter" | "AddLast";
                            /** @description Value of xDS resource in YAML format to add or patch. */
                            value?: string;
                        };
                        /** @description VirtualHost is a modification of Envoy's VirtualHost
                         *     referenced in HTTP Connection Manager in a Listener resource. */
                        virtualHost?: {
                            /** @description JsonPatches specifies list of jsonpatches to apply to on Envoy's
                             *     VirtualHost resource */
                            jsonPatches?: {
                                /** @description From is a jsonpatch from string, used by move and copy operations. */
                                from?: string;
                                /**
                                 * @description Op is a jsonpatch operation string.
                                 * @enum {string}
                                 */
                                op: "add" | "remove" | "replace" | "move" | "copy";
                                /** @description Path is a jsonpatch path string. */
                                path: string;
                                /** @description Value must be a valid json value used by replace and add operations. */
                                value?: unknown;
                            }[];
                            /** @description Match is a set of conditions that have to be matched for modification operation to happen. */
                            match: {
                                /** @description Name of the VirtualHost to match. */
                                name?: string;
                                /** @description Origin is the name of the component or plugin that generated the resource.
                                 *
                                 *     Here is the list of well-known origins:
                                 *     inbound - resources generated for handling incoming traffic.
                                 *     outbound - resources generated for handling outgoing traffic.
                                 *     transparent - resources generated for transparent proxy functionality.
                                 *     prometheus - resources generated when Prometheus metrics are enabled.
                                 *     direct-access - resources generated for Direct Access functionality.
                                 *     ingress - resources generated for Zone Ingress.
                                 *     egress - resources generated for Zone Egress.
                                 *     gateway - resources generated for MeshGateway.
                                 *
                                 *     The list is not complete, because policy plugins can introduce new resources.
                                 *     For example MeshTrace plugin can create Cluster with "mesh-trace" origin. */
                                origin?: string;
                                /** @description Name of the RouteConfiguration resource to match. */
                                routeConfigurationName?: string;
                            };
                            /**
                             * @description Operation to execute on matched listener.
                             * @enum {string}
                             */
                            operation: "Add" | "Remove" | "Patch";
                            /** @description Value of xDS resource in YAML format to add or patch. */
                            value?: string;
                        };
                    }[];
                };
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined inplace. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshProxyPatchCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshProxyPatchDeleteSuccessResponse: Record<string, never>;
        MeshRateLimitItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshRateLimit";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshRateLimit resource. */
            spec: {
                /** @description From list makes a match between clients and corresponding configurations */
                from?: {
                    /** @description Default is a configuration specific to the group of clients referenced in
                     *     'targetRef' */
                    default?: {
                        /** @description LocalConf defines local http or/and tcp rate limit configuration */
                        local?: {
                            /** @description LocalHTTP defines configuration of local HTTP rate limiting
                             *     https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/local_rate_limit_filter */
                            http?: {
                                /** @description Define if rate limiting should be disabled. */
                                disabled?: boolean;
                                /** @description Describes the actions to take on a rate limit event */
                                onRateLimit?: {
                                    /** @description The Headers to be added to the HTTP response on a rate limit event */
                                    headers?: {
                                        add?: {
                                            name: string;
                                            value: string;
                                        }[];
                                        set?: {
                                            name: string;
                                            value: string;
                                        }[];
                                    };
                                    /**
                                     * Format: int32
                                     * @description The HTTP status code to be set on a rate limit event
                                     */
                                    status?: number;
                                };
                                /** @description Defines how many requests are allowed per interval. */
                                requestRate?: {
                                    /** @description The interval the number of units is accounted for. */
                                    interval: string;
                                    /**
                                     * Format: int32
                                     * @description Number of units per interval (depending on usage it can be a number of requests,
                                     *     or a number of connections).
                                     */
                                    num: number;
                                };
                            };
                            /** @description LocalTCP defines confguration of local TCP rate limiting
                             *     https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/local_rate_limit_filter */
                            tcp?: {
                                /** @description Defines how many connections are allowed per interval. */
                                connectionRate?: {
                                    /** @description The interval the number of units is accounted for. */
                                    interval: string;
                                    /**
                                     * Format: int32
                                     * @description Number of units per interval (depending on usage it can be a number of requests,
                                     *     or a number of connections).
                                     */
                                    num: number;
                                };
                                /** @description Define if rate limiting should be disabled.
                                 *     Default: false */
                                disabled?: boolean;
                            };
                        };
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     clients. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
                /** @description Rules defines inbound rate limiting configurations. Currently limited to
                 *     selecting all inbound traffic, as L7 matching is not yet implemented. */
                rules?: {
                    /** @description Default contains configuration of the inbound rate limits */
                    default?: {
                        /** @description LocalConf defines local http or/and tcp rate limit configuration */
                        local?: {
                            /** @description LocalHTTP defines configuration of local HTTP rate limiting
                             *     https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/local_rate_limit_filter */
                            http?: {
                                /** @description Define if rate limiting should be disabled. */
                                disabled?: boolean;
                                /** @description Describes the actions to take on a rate limit event */
                                onRateLimit?: {
                                    /** @description The Headers to be added to the HTTP response on a rate limit event */
                                    headers?: {
                                        add?: {
                                            name: string;
                                            value: string;
                                        }[];
                                        set?: {
                                            name: string;
                                            value: string;
                                        }[];
                                    };
                                    /**
                                     * Format: int32
                                     * @description The HTTP status code to be set on a rate limit event
                                     */
                                    status?: number;
                                };
                                /** @description Defines how many requests are allowed per interval. */
                                requestRate?: {
                                    /** @description The interval the number of units is accounted for. */
                                    interval: string;
                                    /**
                                     * Format: int32
                                     * @description Number of units per interval (depending on usage it can be a number of requests,
                                     *     or a number of connections).
                                     */
                                    num: number;
                                };
                            };
                            /** @description LocalTCP defines confguration of local TCP rate limiting
                             *     https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/local_rate_limit_filter */
                            tcp?: {
                                /** @description Defines how many connections are allowed per interval. */
                                connectionRate?: {
                                    /** @description The interval the number of units is accounted for. */
                                    interval: string;
                                    /**
                                     * Format: int32
                                     * @description Number of units per interval (depending on usage it can be a number of requests,
                                     *     or a number of connections).
                                     */
                                    num: number;
                                };
                                /** @description Define if rate limiting should be disabled.
                                 *     Default: false */
                                disabled?: boolean;
                            };
                        };
                    };
                }[];
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined inplace. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
                /** @description To list makes a match between clients and corresponding configurations */
                to?: {
                    /** @description Default is a configuration specific to the group of clients referenced in
                     *     'targetRef' */
                    default?: {
                        /** @description LocalConf defines local http or/and tcp rate limit configuration */
                        local?: {
                            /** @description LocalHTTP defines configuration of local HTTP rate limiting
                             *     https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/local_rate_limit_filter */
                            http?: {
                                /** @description Define if rate limiting should be disabled. */
                                disabled?: boolean;
                                /** @description Describes the actions to take on a rate limit event */
                                onRateLimit?: {
                                    /** @description The Headers to be added to the HTTP response on a rate limit event */
                                    headers?: {
                                        add?: {
                                            name: string;
                                            value: string;
                                        }[];
                                        set?: {
                                            name: string;
                                            value: string;
                                        }[];
                                    };
                                    /**
                                     * Format: int32
                                     * @description The HTTP status code to be set on a rate limit event
                                     */
                                    status?: number;
                                };
                                /** @description Defines how many requests are allowed per interval. */
                                requestRate?: {
                                    /** @description The interval the number of units is accounted for. */
                                    interval: string;
                                    /**
                                     * Format: int32
                                     * @description Number of units per interval (depending on usage it can be a number of requests,
                                     *     or a number of connections).
                                     */
                                    num: number;
                                };
                            };
                            /** @description LocalTCP defines confguration of local TCP rate limiting
                             *     https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/local_rate_limit_filter */
                            tcp?: {
                                /** @description Defines how many connections are allowed per interval. */
                                connectionRate?: {
                                    /** @description The interval the number of units is accounted for. */
                                    interval: string;
                                    /**
                                     * Format: int32
                                     * @description Number of units per interval (depending on usage it can be a number of requests,
                                     *     or a number of connections).
                                     */
                                    num: number;
                                };
                                /** @description Define if rate limiting should be disabled.
                                 *     Default: false */
                                disabled?: boolean;
                            };
                        };
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     clients. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshRateLimitCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshRateLimitDeleteSuccessResponse: Record<string, never>;
        MeshRetryItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshRetry";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshRetry resource. */
            spec: {
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined inplace. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
                /** @description To list makes a match between the consumed services and corresponding configurations */
                to?: {
                    /** @description Default is a configuration specific to the group of destinations referenced in
                     *     'targetRef' */
                    default?: {
                        /** @description GRPC defines a configuration of retries for GRPC traffic */
                        grpc?: {
                            /** @description BackOff is a configuration of durations which will be used in an exponential
                             *     backoff strategy between retries. */
                            backOff?: {
                                /** @description BaseInterval is an amount of time which should be taken between retries.
                                 *     Must be greater than zero. Values less than 1 ms are rounded up to 1 ms.
                                 *     If not specified then the default value is "25ms". */
                                baseInterval?: string;
                                /** @description MaxInterval is a maximal amount of time which will be taken between retries.
                                 *     Default is 10 times the "BaseInterval". */
                                maxInterval?: string;
                            };
                            /**
                             * Format: int32
                             * @description NumRetries is the number of attempts that will be made on failed (and
                             *     retriable) requests. If not set, the default value is 1.
                             */
                            numRetries?: number;
                            /** @description PerTryTimeout is the maximum amount of time each retry attempt can take
                             *     before it times out. If not set, the global request timeout for the route
                             *     will be used. Setting this value to 0 will disable the per-try timeout. */
                            perTryTimeout?: string;
                            /** @description RateLimitedBackOff is a configuration of backoff which will be used when
                             *     the upstream returns one of the headers configured. */
                            rateLimitedBackOff?: {
                                /** @description MaxInterval is a maximal amount of time which will be taken between retries.
                                 *     If not specified then the default value is "300s". */
                                maxInterval?: string;
                                /** @description ResetHeaders specifies the list of headers (like Retry-After or X-RateLimit-Reset)
                                 *     to match against the response. Headers are tried in order, and matched
                                 *     case-insensitive. The first header to be parsed successfully is used.
                                 *     If no headers match the default exponential BackOff is used instead. */
                                resetHeaders?: {
                                    /**
                                     * @description The format of the reset header.
                                     * @enum {string}
                                     */
                                    format: "Seconds" | "UnixTimestamp";
                                    /** @description The Name of the reset header. */
                                    name: string;
                                }[];
                            };
                            /**
                             * @description RetryOn is a list of conditions which will cause a retry.
                             * @example [
                             *       "Canceled",
                             *       "DeadlineExceeded",
                             *       "Internal",
                             *       "ResourceExhausted",
                             *       "Unavailable"
                             *     ]
                             */
                            retryOn?: ("Canceled" | "DeadlineExceeded" | "Internal" | "ResourceExhausted" | "Unavailable")[];
                        };
                        /** @description HTTP defines a configuration of retries for HTTP traffic */
                        http?: {
                            /** @description BackOff is a configuration of durations which will be used in exponential
                             *     backoff strategy between retries. */
                            backOff?: {
                                /** @description BaseInterval is an amount of time which should be taken between retries.
                                 *     Must be greater than zero. Values less than 1 ms are rounded up to 1 ms.
                                 *     If not specified then the default value is "25ms". */
                                baseInterval?: string;
                                /** @description MaxInterval is a maximal amount of time which will be taken between retries.
                                 *     Default is 10 times the "BaseInterval". */
                                maxInterval?: string;
                            };
                            /** @description HostSelection is a list of predicates that dictate how hosts should be selected
                             *     when requests are retried. */
                            hostSelection?: {
                                /**
                                 * @description Type is requested predicate mode.
                                 * @enum {string}
                                 */
                                predicate: "OmitPreviousHosts" | "OmitHostsWithTags" | "OmitPreviousPriorities";
                                /** @description Tags is a map of metadata to match against for selecting the omitted hosts. Required if Type is
                                 *     OmitHostsWithTags */
                                tags?: {
                                    [key: string]: string;
                                };
                                /**
                                 * Format: int32
                                 * @description UpdateFrequency is how often the priority load should be updated based on previously attempted priorities.
                                 *     Used for OmitPreviousPriorities.
                                 * @default 2
                                 */
                                updateFrequency: number;
                            }[];
                            /**
                             * Format: int64
                             * @description HostSelectionMaxAttempts is the maximum number of times host selection will be
                             *     reattempted before giving up, at which point the host that was last selected will
                             *     be routed to. If unspecified, this will default to retrying once.
                             */
                            hostSelectionMaxAttempts?: number;
                            /**
                             * Format: int32
                             * @description NumRetries is the number of attempts that will be made on failed (and
                             *     retriable) requests.  If not set, the default value is 1.
                             */
                            numRetries?: number;
                            /** @description PerTryTimeout is the amount of time after which retry attempt should time out.
                             *     If left unspecified, the global route timeout for the request will be used.
                             *     Consequently, when using a 5xx based retry policy, a request that times out
                             *     will not be retried as the total timeout budget would have been exhausted.
                             *     Setting this timeout to 0 will disable it. */
                            perTryTimeout?: string;
                            /** @description RateLimitedBackOff is a configuration of backoff which will be used
                             *     when the upstream returns one of the headers configured. */
                            rateLimitedBackOff?: {
                                /** @description MaxInterval is a maximal amount of time which will be taken between retries.
                                 *     If not specified then the default value is "300s". */
                                maxInterval?: string;
                                /** @description ResetHeaders specifies the list of headers (like Retry-After or X-RateLimit-Reset)
                                 *     to match against the response. Headers are tried in order, and matched
                                 *     case-insensitive. The first header to be parsed successfully is used.
                                 *     If no headers match the default exponential BackOff is used instead. */
                                resetHeaders?: {
                                    /**
                                     * @description The format of the reset header.
                                     * @enum {string}
                                     */
                                    format: "Seconds" | "UnixTimestamp";
                                    /** @description The Name of the reset header. */
                                    name: string;
                                }[];
                            };
                            /** @description RetriableRequestHeaders is an HTTP headers which must be present in the request
                             *     for retries to be attempted. */
                            retriableRequestHeaders?: {
                                /** @description Name is the name of the HTTP Header to be matched. Name MUST be lower case
                                 *     as they will be handled with case insensitivity (See https://tools.ietf.org/html/rfc7230#section-3.2). */
                                name: string;
                                /**
                                 * @description Type specifies how to match against the value of the header.
                                 * @default Exact
                                 * @enum {string}
                                 */
                                type: "Exact" | "Present" | "RegularExpression" | "Absent" | "Prefix";
                                /** @description Value is the value of HTTP Header to be matched. */
                                value?: string;
                            }[];
                            /** @description RetriableResponseHeaders is an HTTP response headers that trigger a retry
                             *     if present in the response. A retry will be triggered if any of the header
                             *     matches the upstream response headers. */
                            retriableResponseHeaders?: {
                                /** @description Name is the name of the HTTP Header to be matched. Name MUST be lower case
                                 *     as they will be handled with case insensitivity (See https://tools.ietf.org/html/rfc7230#section-3.2). */
                                name: string;
                                /**
                                 * @description Type specifies how to match against the value of the header.
                                 * @default Exact
                                 * @enum {string}
                                 */
                                type: "Exact" | "Present" | "RegularExpression" | "Absent" | "Prefix";
                                /** @description Value is the value of HTTP Header to be matched. */
                                value?: string;
                            }[];
                            /**
                             * @description RetryOn is a list of conditions which will cause a retry. Available values are:
                             *     [5XX, GatewayError, Reset, Retriable4xx, ConnectFailure, EnvoyRatelimited,
                             *     RefusedStream, Http3PostConnectFailure, HttpMethodConnect, HttpMethodDelete,
                             *     HttpMethodGet, HttpMethodHead, HttpMethodOptions, HttpMethodPatch,
                             *     HttpMethodPost, HttpMethodPut, HttpMethodTrace].
                             *     Also, any HTTP status code (500, 503, etc.).
                             * @example [
                             *       "5XX",
                             *       "GatewayError",
                             *       "Reset",
                             *       "Retriable4xx",
                             *       "ConnectFailure",
                             *       "EnvoyRatelimited",
                             *       "RefusedStream",
                             *       "Http3PostConnectFailure",
                             *       "HttpMethodConnect",
                             *       "HttpMethodDelete",
                             *       "HttpMethodGet",
                             *       "HttpMethodHead",
                             *       "HttpMethodOptions",
                             *       "HttpMethodPatch",
                             *       "HttpMethodPost",
                             *       "HttpMethodPut",
                             *       "HttpMethodTrace",
                             *       "500",
                             *       "503"
                             *     ]
                             */
                            retryOn?: string[];
                        };
                        /** @description TCP defines a configuration of retries for TCP traffic */
                        tcp?: {
                            /**
                             * Format: int32
                             * @description MaxConnectAttempt is a maximal amount of TCP connection attempts
                             *     which will be made before giving up
                             */
                            maxConnectAttempt?: number;
                        };
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     destinations. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshRetryCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshRetryDeleteSuccessResponse: Record<string, never>;
        MeshTCPRouteItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshTCPRoute";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshTCPRoute resource. */
            spec: {
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined in-place. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
                /** @description To list makes a match between the consumed services and corresponding
                 *     configurations */
                to?: {
                    /** @description Rules contains the routing rules applies to a combination of top-level
                     *     targetRef and the targetRef in this entry. */
                    rules: {
                        /** @description Default holds routing rules that can be merged with rules from other
                         *     policies. */
                        default: {
                            backendRefs?: {
                                /**
                                 * @description Kind of the referenced resource
                                 * @enum {string}
                                 */
                                kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                                /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                                 *     Name and Namespace can be used. */
                                labels?: {
                                    [key: string]: string;
                                };
                                /** @description Mesh is reserved for future use to identify cross mesh resources. */
                                mesh?: string;
                                /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                                 *     `MeshServiceSubset` and `MeshGatewayRoute` */
                                name?: string;
                                /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                                 *     will be targeted. */
                                namespace?: string;
                                /**
                                 * Format: int32
                                 * @description Port is only supported when this ref refers to a real MeshService object
                                 */
                                port?: number;
                                /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                                 *     all data plane types are targeted by the policy. */
                                proxyTypes?: ("Sidecar" | "Gateway")[];
                                /** @description SectionName is used to target specific section of resource.
                                 *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                                sectionName?: string;
                                /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                                 *     `MeshSubset` and `MeshServiceSubset` */
                                tags?: {
                                    [key: string]: string;
                                };
                                /** @default 1 */
                                weight: number;
                            }[];
                        };
                    }[];
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     destinations. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshTCPRouteCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshTCPRouteDeleteSuccessResponse: Record<string, never>;
        MeshTimeoutItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshTimeout";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshTimeout resource. */
            spec: {
                /** @description From list makes a match between clients and corresponding configurations */
                from?: {
                    /** @description Default is a configuration specific to the group of clients referenced in
                     *     'targetRef' */
                    default?: {
                        /** @description ConnectionTimeout specifies the amount of time proxy will wait for an TCP connection to be established.
                         *     Default value is 5 seconds. Cannot be set to 0. */
                        connectionTimeout?: string;
                        /** @description Http provides configuration for HTTP specific timeouts */
                        http?: {
                            /** @description MaxConnectionDuration is the time after which a connection will be drained and/or closed,
                             *     starting from when it was first established. Setting this timeout to 0 will disable it.
                             *     Disabled by default. */
                            maxConnectionDuration?: string;
                            /** @description MaxStreamDuration is the maximum time that a stream’s lifetime will span.
                             *     Setting this timeout to 0 will disable it. Disabled by default. */
                            maxStreamDuration?: string;
                            /** @description RequestHeadersTimeout The amount of time that proxy will wait for the request headers to be received. The timer is
                             *     activated when the first byte of the headers is received, and is disarmed when the last byte of
                             *     the headers has been received. If not specified or set to 0, this timeout is disabled.
                             *     Disabled by default. */
                            requestHeadersTimeout?: string;
                            /** @description RequestTimeout The amount of time that proxy will wait for the entire request to be received.
                             *     The timer is activated when the request is initiated, and is disarmed when the last byte of the request is sent,
                             *     OR when the response is initiated. Setting this timeout to 0 will disable it.
                             *     Default is 15s. */
                            requestTimeout?: string;
                            /** @description StreamIdleTimeout is the amount of time that proxy will allow a stream to exist with no activity.
                             *     Setting this timeout to 0 will disable it. Default is 30m */
                            streamIdleTimeout?: string;
                        };
                        /** @description IdleTimeout is defined as the period in which there are no bytes sent or received on connection
                         *     Setting this timeout to 0 will disable it. Be cautious when disabling it because
                         *     it can lead to connection leaking. Default value is 1h. */
                        idleTimeout?: string;
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     clients. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
                /** @description Rules defines inbound timeout configurations. Currently limited to exactly one rule containing
                 *     default timeouts that apply to all inbound traffic, as L7 matching is not yet implemented. */
                rules?: {
                    /** @description Default contains configuration of the inbound timeouts */
                    default?: {
                        /** @description ConnectionTimeout specifies the amount of time proxy will wait for an TCP connection to be established.
                         *     Default value is 5 seconds. Cannot be set to 0. */
                        connectionTimeout?: string;
                        /** @description Http provides configuration for HTTP specific timeouts */
                        http?: {
                            /** @description MaxConnectionDuration is the time after which a connection will be drained and/or closed,
                             *     starting from when it was first established. Setting this timeout to 0 will disable it.
                             *     Disabled by default. */
                            maxConnectionDuration?: string;
                            /** @description MaxStreamDuration is the maximum time that a stream’s lifetime will span.
                             *     Setting this timeout to 0 will disable it. Disabled by default. */
                            maxStreamDuration?: string;
                            /** @description RequestHeadersTimeout The amount of time that proxy will wait for the request headers to be received. The timer is
                             *     activated when the first byte of the headers is received, and is disarmed when the last byte of
                             *     the headers has been received. If not specified or set to 0, this timeout is disabled.
                             *     Disabled by default. */
                            requestHeadersTimeout?: string;
                            /** @description RequestTimeout The amount of time that proxy will wait for the entire request to be received.
                             *     The timer is activated when the request is initiated, and is disarmed when the last byte of the request is sent,
                             *     OR when the response is initiated. Setting this timeout to 0 will disable it.
                             *     Default is 15s. */
                            requestTimeout?: string;
                            /** @description StreamIdleTimeout is the amount of time that proxy will allow a stream to exist with no activity.
                             *     Setting this timeout to 0 will disable it. Default is 30m */
                            streamIdleTimeout?: string;
                        };
                        /** @description IdleTimeout is defined as the period in which there are no bytes sent or received on connection
                         *     Setting this timeout to 0 will disable it. Be cautious when disabling it because
                         *     it can lead to connection leaking. Default value is 1h. */
                        idleTimeout?: string;
                    };
                }[];
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined inplace. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
                /** @description To list makes a match between the consumed services and corresponding configurations */
                to?: {
                    /** @description Default is a configuration specific to the group of destinations referenced in
                     *     'targetRef' */
                    default?: {
                        /** @description ConnectionTimeout specifies the amount of time proxy will wait for an TCP connection to be established.
                         *     Default value is 5 seconds. Cannot be set to 0. */
                        connectionTimeout?: string;
                        /** @description Http provides configuration for HTTP specific timeouts */
                        http?: {
                            /** @description MaxConnectionDuration is the time after which a connection will be drained and/or closed,
                             *     starting from when it was first established. Setting this timeout to 0 will disable it.
                             *     Disabled by default. */
                            maxConnectionDuration?: string;
                            /** @description MaxStreamDuration is the maximum time that a stream’s lifetime will span.
                             *     Setting this timeout to 0 will disable it. Disabled by default. */
                            maxStreamDuration?: string;
                            /** @description RequestHeadersTimeout The amount of time that proxy will wait for the request headers to be received. The timer is
                             *     activated when the first byte of the headers is received, and is disarmed when the last byte of
                             *     the headers has been received. If not specified or set to 0, this timeout is disabled.
                             *     Disabled by default. */
                            requestHeadersTimeout?: string;
                            /** @description RequestTimeout The amount of time that proxy will wait for the entire request to be received.
                             *     The timer is activated when the request is initiated, and is disarmed when the last byte of the request is sent,
                             *     OR when the response is initiated. Setting this timeout to 0 will disable it.
                             *     Default is 15s. */
                            requestTimeout?: string;
                            /** @description StreamIdleTimeout is the amount of time that proxy will allow a stream to exist with no activity.
                             *     Setting this timeout to 0 will disable it. Default is 30m */
                            streamIdleTimeout?: string;
                        };
                        /** @description IdleTimeout is defined as the period in which there are no bytes sent or received on connection
                         *     Setting this timeout to 0 will disable it. Be cautious when disabling it because
                         *     it can lead to connection leaking. Default value is 1h. */
                        idleTimeout?: string;
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     destinations. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshTimeoutCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshTimeoutDeleteSuccessResponse: Record<string, never>;
        MeshTLSItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshTLS";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshTLS resource. */
            spec: {
                /** @description From list makes a match between clients and corresponding configurations */
                from?: {
                    /** @description Default is a configuration specific to the group of clients referenced in
                     *     'targetRef' */
                    default?: {
                        /**
                         * @description Mode defines the behavior of inbound listeners with regard to traffic encryption.
                         * @enum {string}
                         */
                        mode?: "Permissive" | "Strict";
                        /** @description TlsCiphers section for providing ciphers specification. */
                        tlsCiphers?: ("ECDHE-ECDSA-AES128-GCM-SHA256" | "ECDHE-ECDSA-AES256-GCM-SHA384" | "ECDHE-ECDSA-CHACHA20-POLY1305" | "ECDHE-RSA-AES128-GCM-SHA256" | "ECDHE-RSA-AES256-GCM-SHA384" | "ECDHE-RSA-CHACHA20-POLY1305")[];
                        /** @description Version section for providing version specification. */
                        tlsVersion?: {
                            /**
                             * @description Max defines maximum supported version. One of `TLSAuto`, `TLS10`, `TLS11`, `TLS12`, `TLS13`.
                             * @default TLSAuto
                             * @enum {string}
                             */
                            max: "TLSAuto" | "TLS10" | "TLS11" | "TLS12" | "TLS13";
                            /**
                             * @description Min defines minimum supported version. One of `TLSAuto`, `TLS10`, `TLS11`, `TLS12`, `TLS13`.
                             * @default TLSAuto
                             * @enum {string}
                             */
                            min: "TLSAuto" | "TLS10" | "TLS11" | "TLS12" | "TLS13";
                        };
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     clients. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
                /** @description Rules defines inbound tls configurations. Currently limited to
                 *     selecting all inbound traffic, as L7 matching is not yet implemented. */
                rules?: {
                    /** @description Default contains configuration of the inbound tls */
                    default?: {
                        /**
                         * @description Mode defines the behavior of inbound listeners with regard to traffic encryption.
                         * @enum {string}
                         */
                        mode?: "Permissive" | "Strict";
                        /** @description TlsCiphers section for providing ciphers specification. */
                        tlsCiphers?: ("ECDHE-ECDSA-AES128-GCM-SHA256" | "ECDHE-ECDSA-AES256-GCM-SHA384" | "ECDHE-ECDSA-CHACHA20-POLY1305" | "ECDHE-RSA-AES128-GCM-SHA256" | "ECDHE-RSA-AES256-GCM-SHA384" | "ECDHE-RSA-CHACHA20-POLY1305")[];
                        /** @description Version section for providing version specification. */
                        tlsVersion?: {
                            /**
                             * @description Max defines maximum supported version. One of `TLSAuto`, `TLS10`, `TLS11`, `TLS12`, `TLS13`.
                             * @default TLSAuto
                             * @enum {string}
                             */
                            max: "TLSAuto" | "TLS10" | "TLS11" | "TLS12" | "TLS13";
                            /**
                             * @description Min defines minimum supported version. One of `TLSAuto`, `TLS10`, `TLS11`, `TLS12`, `TLS13`.
                             * @default TLSAuto
                             * @enum {string}
                             */
                            min: "TLSAuto" | "TLS10" | "TLS11" | "TLS12" | "TLS13";
                        };
                    };
                }[];
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined in-place. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshTLSCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshTLSDeleteSuccessResponse: Record<string, never>;
        MeshTraceItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshTrace";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshTrace resource. */
            spec: {
                /** @description MeshTrace configuration. */
                default?: {
                    /** @description A one element array of backend definition.
                     *     Envoy allows configuring only 1 backend, so the natural way of
                     *     representing that would be just one object. Unfortunately due to the
                     *     reasons explained in MADR 009-tracing-policy this has to be a one element
                     *     array for now. */
                    backends?: {
                        /** @description Datadog backend configuration. */
                        datadog?: {
                            /**
                             * @description Determines if datadog service name should be split based on traffic
                             *     direction and destination. For example, with `splitService: true` and a
                             *     `backend` service that communicates with a couple of databases, you would
                             *     get service names like `backend_INBOUND`, `backend_OUTBOUND_db1`, and
                             *     `backend_OUTBOUND_db2` in Datadog.
                             * @default false
                             */
                            splitService: boolean;
                            /** @description Address of Datadog collector, only host and port are allowed (no paths,
                             *     fragments etc.) */
                            url: string;
                        };
                        /** @description OpenTelemetry backend configuration. */
                        openTelemetry?: {
                            /**
                             * @description Address of OpenTelemetry collector.
                             * @example otel-collector:4317
                             */
                            endpoint: string;
                        };
                        /** @enum {string} */
                        type: "Zipkin" | "Datadog" | "OpenTelemetry";
                        /** @description Zipkin backend configuration. */
                        zipkin?: {
                            /**
                             * @description Version of the API.
                             *     https://github.com/envoyproxy/envoy/blob/v1.22.0/api/envoy/config/trace/v3/zipkin.proto#L66
                             * @default httpJson
                             * @enum {string}
                             */
                            apiVersion: "httpJson" | "httpProto";
                            /**
                             * @description Determines whether client and server spans will share the same span
                             *     context.
                             *     https://github.com/envoyproxy/envoy/blob/v1.22.0/api/envoy/config/trace/v3/zipkin.proto#L63
                             * @default true
                             */
                            sharedSpanContext: boolean;
                            /**
                             * @description Generate 128bit traces.
                             * @default false
                             */
                            traceId128bit: boolean;
                            /** @description Address of Zipkin collector. */
                            url: string;
                        };
                    }[];
                    /** @description Sampling configuration.
                     *     Sampling is the process by which a decision is made on whether to
                     *     process/export a span or not. */
                    sampling?: {
                        /** @description Target percentage of requests that will be force traced if the
                         *     'x-client-trace-id' header is set. Mirror of client_sampling in Envoy
                         *     https://github.com/envoyproxy/envoy/blob/v1.22.0/api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto#L127-L133
                         *     Either int or decimal represented as string.
                         *     If not specified then the default value is 100. */
                        client?: number | string;
                        /** @description Target percentage of requests will be traced
                         *     after all other sampling checks have been applied (client, force tracing,
                         *     random sampling). This field functions as an upper limit on the total
                         *     configured sampling rate. For instance, setting client to 100
                         *     but overall to 1 will result in only 1% of client requests with
                         *     the appropriate headers to be force traced. Mirror of
                         *     overall_sampling in Envoy
                         *     https://github.com/envoyproxy/envoy/blob/v1.22.0/api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto#L142-L150
                         *     Either int or decimal represented as string.
                         *     If not specified then the default value is 100. */
                        overall?: number | string;
                        /** @description Target percentage of requests that will be randomly selected for trace
                         *     generation, if not requested by the client or not forced.
                         *     Mirror of random_sampling in Envoy
                         *     https://github.com/envoyproxy/envoy/blob/v1.22.0/api/envoy/config/filter/network/http_connection_manager/v2/http_connection_manager.proto#L135-L140
                         *     Either int or decimal represented as string.
                         *     If not specified then the default value is 100. */
                        random?: number | string;
                    };
                    /** @description Custom tags configuration. You can add custom tags to traces based on
                     *     headers or literal values. */
                    tags?: {
                        /** @description Tag taken from a header. */
                        header?: {
                            /** @description Default value to use if header is missing.
                             *     If the default is missing and there is no value the tag will not be
                             *     included. */
                            default?: string;
                            /** @description Name of the header. */
                            name: string;
                        };
                        /** @description Tag taken from literal value. */
                        literal?: string;
                        /** @description Name of the tag. */
                        name: string;
                    }[];
                };
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined inplace. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshTraceCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshTraceDeleteSuccessResponse: Record<string, never>;
        MeshTrafficPermissionItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshTrafficPermission";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshTrafficPermission resource. */
            spec: {
                /** @description From list makes a match between clients and corresponding configurations */
                from?: {
                    /** @description Default is a configuration specific to the group of clients referenced in
                     *     'targetRef' */
                    default?: {
                        /**
                         * @description Action defines a behavior for the specified group of clients:
                         * @enum {string}
                         */
                        action?: "Allow" | "Deny" | "AllowWithShadowDeny";
                    };
                    /** @description TargetRef is a reference to the resource that represents a group of
                     *     clients. */
                    targetRef: {
                        /**
                         * @description Kind of the referenced resource
                         * @enum {string}
                         */
                        kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                        /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                         *     Name and Namespace can be used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Mesh is reserved for future use to identify cross mesh resources. */
                        mesh?: string;
                        /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                         *     `MeshServiceSubset` and `MeshGatewayRoute` */
                        name?: string;
                        /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                         *     will be targeted. */
                        namespace?: string;
                        /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                         *     all data plane types are targeted by the policy. */
                        proxyTypes?: ("Sidecar" | "Gateway")[];
                        /** @description SectionName is used to target specific section of resource.
                         *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                        sectionName?: string;
                        /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                         *     `MeshSubset` and `MeshServiceSubset` */
                        tags?: {
                            [key: string]: string;
                        };
                    };
                }[];
                /** @description Rules defines inbound permissions configuration */
                rules?: {
                    default: {
                        /** @description Allow definees a list of matches for which access will be allowed */
                        allow?: {
                            /** @description SpiffeId defines a matcher configuration for SpiffeId matching */
                            spiffeId?: {
                                /**
                                 * @description Type defines how to match incoming traffic by SpiffeId. `Exact` or `Prefix` are allowed.
                                 * @enum {string}
                                 */
                                type: "Exact" | "Prefix";
                                /** @description Value is SpiffeId of a client that needs to match for the configuration to be applied */
                                value: string;
                            };
                        }[];
                        /** @description AllowWithShadowDeny defines a list of matches for which access will be allowed but emits logs as if
                         *     requests are denied */
                        allowWithShadowDeny?: {
                            /** @description SpiffeId defines a matcher configuration for SpiffeId matching */
                            spiffeId?: {
                                /**
                                 * @description Type defines how to match incoming traffic by SpiffeId. `Exact` or `Prefix` are allowed.
                                 * @enum {string}
                                 */
                                type: "Exact" | "Prefix";
                                /** @description Value is SpiffeId of a client that needs to match for the configuration to be applied */
                                value: string;
                            };
                        }[];
                        /** @description Deny defines a list of matches for which access will be denied */
                        deny?: {
                            /** @description SpiffeId defines a matcher configuration for SpiffeId matching */
                            spiffeId?: {
                                /**
                                 * @description Type defines how to match incoming traffic by SpiffeId. `Exact` or `Prefix` are allowed.
                                 * @enum {string}
                                 */
                                type: "Exact" | "Prefix";
                                /** @description Value is SpiffeId of a client that needs to match for the configuration to be applied */
                                value: string;
                            };
                        }[];
                    };
                }[];
                /** @description TargetRef is a reference to the resource the policy takes an effect on.
                 *     The resource could be either a real store object or virtual resource
                 *     defined inplace. */
                targetRef?: {
                    /**
                     * @description Kind of the referenced resource
                     * @enum {string}
                     */
                    kind: "Mesh" | "MeshSubset" | "MeshGateway" | "MeshService" | "MeshExternalService" | "MeshMultiZoneService" | "MeshServiceSubset" | "MeshHTTPRoute" | "Dataplane";
                    /** @description Labels are used to select group of MeshServices that match labels. Either Labels or
                     *     Name and Namespace can be used. */
                    labels?: {
                        [key: string]: string;
                    };
                    /** @description Mesh is reserved for future use to identify cross mesh resources. */
                    mesh?: string;
                    /** @description Name of the referenced resource. Can only be used with kinds: `MeshService`,
                     *     `MeshServiceSubset` and `MeshGatewayRoute` */
                    name?: string;
                    /** @description Namespace specifies the namespace of target resource. If empty only resources in policy namespace
                     *     will be targeted. */
                    namespace?: string;
                    /** @description ProxyTypes specifies the data plane types that are subject to the policy. When not specified,
                     *     all data plane types are targeted by the policy. */
                    proxyTypes?: ("Sidecar" | "Gateway")[];
                    /** @description SectionName is used to target specific section of resource.
                     *     For example, you can target port from MeshService.ports[] by its name. Only traffic to this port will be affected. */
                    sectionName?: string;
                    /** @description Tags used to select a subset of proxies by tags. Can only be used with kinds
                     *     `MeshSubset` and `MeshServiceSubset` */
                    tags?: {
                        [key: string]: string;
                    };
                };
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshTrafficPermissionCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshTrafficPermissionDeleteSuccessResponse: Record<string, never>;
        BuiltinCertificateAuthorityConfig: {
            caCert?: {
                expiration?: string;
                /** Format: uint32 */
                rsaBits?: number;
            };
        };
        DatadogTracingBackendConfig: {
            /** @description Address of datadog collector. */
            address?: string;
            /** @description Port of datadog collector */
            port?: number;
            /** @description Determines if datadog service name should be split based on traffic
             *     direction and destination. For example, with `splitService: true` and a
             *     `backend` service that communicates with a couple of databases, you would
             *     get service names like `backend_INBOUND`, `backend_OUTBOUND_db1`, and
             *     `backend_OUTBOUND_db2` in Datadog. Default: false */
            splitService?: boolean;
        };
        DataplaneItem: {
            labels?: {
                [key: string]: string;
            };
            mesh: string;
            /** @description Configuration for metrics that should be collected and exposed by the
             *     data plane proxy.
             *
             *     Settings defined here will override their respective defaults
             *     defined at a Mesh level. */
            metrics?: {
                conf?: components["schemas"]["PrometheusMetricsBackendConfig"];
                /** @description Name of the backend, can be then used in Mesh.metrics.enabledBackend */
                name?: string;
                /** @description Type of the backend (Kuma ships with 'prometheus') */
                type?: string;
            };
            name: string;
            /** @description Networking describes inbound and outbound interfaces of the data plane
             *     proxy. */
            networking?: {
                /** @description IP on which the data plane proxy is accessible to the control plane and
                 *     other data plane proxies in the same network. This can also be a
                 *     hostname, in which case the control plane will periodically resolve it. */
                address?: string;
                /** @description Admin describes configuration related to Envoy Admin API.
                 *     Due to security, all the Envoy Admin endpoints are exposed only on
                 *     localhost. Additionally, Envoy will expose `/ready` endpoint on
                 *     `networking.address` for health checking systems to be able to check the
                 *     state of Envoy. The rest of the endpoints exposed on `networking.address`
                 *     are always protected by mTLS and only meant to be consumed internally by
                 *     the control plane. */
                admin?: {
                    /** @description Port on which Envoy Admin API server will be listening */
                    port?: number;
                };
                /** @description In some situations, a data plane proxy resides in a private network (e.g.
                 *     Docker) and is not reachable via `address` to other data plane proxies.
                 *     `advertisedAddress` is configured with a routable address for such data
                 *     plane proxy so that other proxies in the mesh can connect to it over
                 *     `advertisedAddress` and not via address.
                 *
                 *     Envoy still binds to the `address`, not `advertisedAddress`. */
                advertisedAddress?: string;
                /** @description Gateway describes a configuration of the gateway of the data plane proxy. */
                gateway?: {
                    /** @description Tags associated with a gateway of this data plane to, e.g.
                     *     `kuma.io/service=gateway`, `env=prod`. `kuma.io/service` tag is
                     *     mandatory. */
                    tags?: {
                        [key: string]: string;
                    };
                    /** @description Type of gateway this data plane proxy manages.
                     *     There are two types: `DELEGATED` and `BUILTIN`. Defaults to
                     *     `DELEGATED`.
                     *
                     *     A `DELEGATED` gateway is an independently deployed proxy (e.g., Kong,
                     *     Contour, etc) that receives inbound traffic that is not proxied by
                     *     Kuma, and it sends outbound traffic into the data plane proxy.
                     *
                     *     The `BUILTIN` gateway type causes the data plane proxy itself to be
                     *     configured as a gateway.
                     *
                     *     See https://kuma.io/docs/latest/explore/gateway/ for more information. */
                    type?: string | number;
                };
                /** @description Inbound describes a list of inbound interfaces of the data plane proxy.
                 *
                 *     Inbound describes a service implemented by the data plane proxy.
                 *     All incoming traffic to a data plane proxy is going through inbound
                 *     listeners. For every defined Inbound there is a corresponding Envoy
                 *     Listener. */
                inbound?: {
                    /** @description Address on which inbound listener will be exposed.
                     *     Defaults to `networking.address`. */
                    address?: string;
                    /** @description Health describes the status of an inbound.
                     *     If 'health' is nil we consider data plane proxy as healthy.
                     *     Unhealthy data plane proxies are excluded from Endpoints Discovery
                     *     Service (EDS). On Kubernetes, it is filled automatically by the control
                     *     plane if Pod has readiness probe configured. On Universal, it can be
                     *     set by the external health checking system, but the most common way is
                     *     to use service probes.
                     *
                     *     See https://kuma.io/docs/latest/documentation/health for more
                     *     information. */
                    health?: {
                        /** @description Ready indicates if the data plane proxy is ready to serve the
                         *     traffic. */
                        ready?: boolean;
                    };
                    /** @description Name adds another way of referencing this port, usable with MeshService */
                    name?: string;
                    /** @description Port of the inbound interface that will forward requests to the
                     *     service.
                     *
                     *     When transparent proxying is used, it is a port on which the service is
                     *     listening to. When transparent proxying is not used, Envoy will bind to
                     *     this port. */
                    port?: number;
                    /** @description Address of the service that requests will be forwarded to.
                     *     Defaults to 'inbound.address', since Kuma DP should be deployed next
                     *     to the service. */
                    serviceAddress?: string;
                    /** @description Port of the service that requests will be forwarded to.
                     *     Defaults to the same value as `port`. */
                    servicePort?: number;
                    /** @description ServiceProbe defines parameters for probing the service next to
                     *     sidecar. When service probe is defined, Envoy will periodically health
                     *     check the application next to it and report the status to the control
                     *     plane. On Kubernetes, Kuma deployments rely on Kubernetes probes so
                     *     this is not used.
                     *
                     *     See https://kuma.io/docs/latest/documentation/health for more
                     *     information. */
                    serviceProbe?: {
                        /**
                         * Format: uint32
                         * @description Number of consecutive healthy checks before considering a host
                         *     healthy.
                         */
                        healthyThreshold?: number;
                        /** @description Interval between consecutive health checks. */
                        interval?: {
                            nanos?: number;
                            seconds?: number;
                        };
                        /** @description Tcp checker tries to establish tcp connection with destination */
                        tcp?: Record<string, never>;
                        /** @description Maximum time to wait for a health check response. */
                        timeout?: {
                            nanos?: number;
                            seconds?: number;
                        };
                        /**
                         * Format: uint32
                         * @description Number of consecutive unhealthy checks before considering a host
                         *     unhealthy.
                         */
                        unhealthyThreshold?: number;
                    };
                    /** @description State describes the current state of the listener. */
                    state?: string | number;
                    /** @description Tags associated with an application this data plane proxy is deployed
                     *     next to, e.g. `kuma.io/service=web`, `version=1.0`. You can then
                     *     reference these tags in policies like MeshTrafficPermission.
                     *     `kuma.io/service` tag is mandatory. */
                    tags?: {
                        [key: string]: string;
                    };
                }[];
                /** @description Outbound describes a list of services consumed by the data plane proxy.
                 *     For every defined Outbound, there is a corresponding Envoy Listener. */
                outbound?: {
                    /** @description IP on which the consumed service will be available to this data plane
                     *     proxy. On Kubernetes, it's usually ClusterIP of a Service or PodIP of a
                     *     Headless Service. Defaults to 127.0.0.1 */
                    address?: string;
                    /** @description BackendRef is a way to target MeshService.
                     *     Experimental. Do not use on production yet. */
                    backendRef?: {
                        /** @description Kind is a type of the object to target. Allowed: MeshService */
                        kind?: string;
                        /** @description Labels to select a single object.
                         *     If no object is selected then outbound is not created.
                         *     If multiple objects are selected then the oldest one is used. */
                        labels?: {
                            [key: string]: string;
                        };
                        /** @description Name of the targeted object */
                        name?: string;
                        /** @description Port of the targeted object. Required when kind is MeshService. */
                        port?: number;
                    };
                    /** @description Port on which the consumed service will be available to this data plane
                     *     proxy. When transparent proxying is not used, Envoy will bind to this
                     *     port. */
                    port?: number;
                    /** @description Tags of consumed data plane proxies.
                     *     `kuma.io/service` tag is required.
                     *     These tags can then be referenced in `destinations` section of policies
                     *     like TrafficRoute or in `to` section in policies like MeshAccessLog. It
                     *     is recommended to only use `kuma.io/service`. If you need to consume
                     *     specific data plane proxy of a service (for example: `version=v2`) the
                     *     better practice is to use TrafficRoute. */
                    tags?: {
                        [key: string]: string;
                    };
                }[];
                /** @description TransparentProxying describes the configuration for transparent proxying.
                 *     It is used by default on Kubernetes. */
                transparentProxying?: {
                    /** @description List of services that will be accessed directly via IP:PORT
                     *     Use `*` to indicate direct access to every service in the Mesh.
                     *     Using `*` to directly access every service is a resource-intensive
                     *     operation, use it only if needed. */
                    directAccessServices?: string[];
                    /** @description The IP family mode to enable for. Can be "IPv4" or "DualStack". */
                    ipFamilyMode?: string | number;
                    /** @description Reachable backend via transparent proxy when running with
                     *     MeshExternalService, MeshService and MeshMultiZoneService. Setting an
                     *     explicit list of refs can dramatically improve the performance of the
                     *     mesh. If not specified, all services in the mesh are reachable. */
                    reachableBackends?: {
                        refs?: {
                            /** @description Type of the backend: MeshService or MeshExternalService
                             *      +required */
                            kind?: string;
                            /** @description Labels used to select backends
                             *      +optional */
                            labels?: {
                                [key: string]: string;
                            };
                            /** @description Name of the backend.
                             *      +optional */
                            name?: string;
                            /** @description Namespace of the backend. Might be empty
                             *      +optional */
                            namespace?: string;
                            /**
                             * Format: uint32
                             * @description Port of the backend.
                             *      +optional
                             */
                            port?: number;
                        }[];
                    };
                    /** @description List of reachable services (represented by the value of
                     *     `kuma.io/service`) via transparent proxying. Setting an explicit list
                     *     can dramatically improve the performance of the mesh. If not specified,
                     *     all services in the mesh are reachable. */
                    reachableServices?: string[];
                    /** @description Port on which all inbound traffic is being transparently redirected. */
                    redirectPortInbound?: number;
                    /** @description Port on which all outbound traffic is being transparently redirected. */
                    redirectPortOutbound?: number;
                };
            };
            /** @description Probes describe a list of endpoints that will be exposed without mTLS.
             *     This is useful to expose the health endpoints of the application so the
             *     orchestration system (e.g. Kubernetes) can still health check the
             *     application.
             *
             *     See
             *     https://kuma.io/docs/latest/policies/service-health-probes/#virtual-probes
             *     for more information.
             *     Deprecated: this feature will be removed for Universal; on Kubernetes, it's
             *     not needed anymore. */
            probes?: {
                /** @description List of endpoints to expose without mTLS. */
                endpoints?: {
                    /** @description Inbound path is a path of the application from which we expose the
                     *     endpoint. It is recommended to be as specific as possible. */
                    inboundPath?: string;
                    /** @description Inbound port is a port of the application from which we expose the
                     *     endpoint. */
                    inboundPort?: number;
                    /** @description Path is a path on which we expose inbound path on the probes port. */
                    path?: string;
                }[];
                /** @description Port on which the probe endpoints will be exposed. This cannot overlap
                 *     with any other ports. */
                port?: number;
            };
            type: string;
        };
        DataplaneCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        DataplaneDeleteSuccessResponse: Record<string, never>;
        PrometheusMetricsBackendConfig: {
            /** @description Map with the configuration of applications which metrics are going to be
             *     scrapped by kuma-dp. */
            aggregate?: {
                /** @description Address on which a service expose HTTP endpoint with Prometheus metrics. */
                address?: string;
                /** @description If false then the application won't be scrapped. If nil, then it is treated
                 *     as true and kuma-dp scrapes metrics from the service. */
                enabled?: boolean;
                /** @description Name which identify given configuration. */
                name?: string;
                /** @description Path on which a service expose HTTP endpoint with Prometheus metrics. */
                path?: string;
                /** @description Port on which a service expose HTTP endpoint with Prometheus metrics. */
                port?: number;
            }[];
            /** @description Configuration of Envoy's metrics. */
            envoy?: {
                /** @description FilterRegex value that is going to be passed to Envoy for filtering
                 *     Envoy metrics. */
                filterRegex?: string;
                /** @description If true then return metrics that Envoy has updated (counters incremented
                 *     at least once, gauges changed at least once, and histograms added to at
                 *     least once). If nil, then it is treated as false. */
                usedOnly?: boolean;
            };
            /** @description Path on which a dataplane should expose HTTP endpoint with Prometheus
             *     metrics. */
            path?: string;
            /** @description Port on which a dataplane should expose HTTP endpoint with Prometheus
             *     metrics. */
            port?: number;
            /** @description If true then endpoints for scraping metrics won't require mTLS even if mTLS
             *     is enabled in Mesh. If nil, then it is treated as false. */
            skipMTLS?: boolean;
            /** @description Tags associated with an application this dataplane is deployed next to,
             *     e.g. service=web, version=1.0.
             *     `service` tag is mandatory. */
            tags?: {
                [key: string]: string;
            };
            /** @description Configuration of TLS for prometheus listener. */
            tls?: {
                /** @description mode defines how configured is the TLS for Prometheus.
                 *     Supported values, delegated, disabled, activeMTLSBackend. Default to
                 *     `activeMTLSBackend`. */
                mode?: string | number;
            };
        };
        DataplaneOverviewWithMeta: components["schemas"]["Meta"] & components["schemas"]["DataplaneOverview"];
        DataplaneOverview: {
            dataplane?: {
                /** @description Configuration for metrics that should be collected and exposed by the
                 *     data plane proxy.
                 *
                 *     Settings defined here will override their respective defaults
                 *     defined at a Mesh level. */
                metrics?: {
                    conf?: components["schemas"]["PrometheusMetricsBackendConfig"];
                    /** @description Name of the backend, can be then used in Mesh.metrics.enabledBackend */
                    name?: string;
                    /** @description Type of the backend (Kuma ships with 'prometheus') */
                    type?: string;
                };
                /** @description Networking describes inbound and outbound interfaces of the data plane
                 *     proxy. */
                networking?: {
                    /** @description IP on which the data plane proxy is accessible to the control plane and
                     *     other data plane proxies in the same network. This can also be a
                     *     hostname, in which case the control plane will periodically resolve it. */
                    address?: string;
                    /** @description Admin describes configuration related to Envoy Admin API.
                     *     Due to security, all the Envoy Admin endpoints are exposed only on
                     *     localhost. Additionally, Envoy will expose `/ready` endpoint on
                     *     `networking.address` for health checking systems to be able to check the
                     *     state of Envoy. The rest of the endpoints exposed on `networking.address`
                     *     are always protected by mTLS and only meant to be consumed internally by
                     *     the control plane. */
                    admin?: {
                        /** @description Port on which Envoy Admin API server will be listening */
                        port?: number;
                    };
                    /** @description In some situations, a data plane proxy resides in a private network (e.g.
                     *     Docker) and is not reachable via `address` to other data plane proxies.
                     *     `advertisedAddress` is configured with a routable address for such data
                     *     plane proxy so that other proxies in the mesh can connect to it over
                     *     `advertisedAddress` and not via address.
                     *
                     *     Envoy still binds to the `address`, not `advertisedAddress`. */
                    advertisedAddress?: string;
                    /** @description Gateway describes a configuration of the gateway of the data plane proxy. */
                    gateway?: {
                        /** @description Tags associated with a gateway of this data plane to, e.g.
                         *     `kuma.io/service=gateway`, `env=prod`. `kuma.io/service` tag is
                         *     mandatory. */
                        tags?: {
                            [key: string]: string;
                        };
                        /** @description Type of gateway this data plane proxy manages.
                         *     There are two types: `DELEGATED` and `BUILTIN`. Defaults to
                         *     `DELEGATED`.
                         *
                         *     A `DELEGATED` gateway is an independently deployed proxy (e.g., Kong,
                         *     Contour, etc) that receives inbound traffic that is not proxied by
                         *     Kuma, and it sends outbound traffic into the data plane proxy.
                         *
                         *     The `BUILTIN` gateway type causes the data plane proxy itself to be
                         *     configured as a gateway.
                         *
                         *     See https://kuma.io/docs/latest/explore/gateway/ for more information. */
                        type?: string | number;
                    };
                    /** @description Inbound describes a list of inbound interfaces of the data plane proxy.
                     *
                     *     Inbound describes a service implemented by the data plane proxy.
                     *     All incoming traffic to a data plane proxy is going through inbound
                     *     listeners. For every defined Inbound there is a corresponding Envoy
                     *     Listener. */
                    inbound?: {
                        /** @description Address on which inbound listener will be exposed.
                         *     Defaults to `networking.address`. */
                        address?: string;
                        /** @description Health describes the status of an inbound.
                         *     If 'health' is nil we consider data plane proxy as healthy.
                         *     Unhealthy data plane proxies are excluded from Endpoints Discovery
                         *     Service (EDS). On Kubernetes, it is filled automatically by the control
                         *     plane if Pod has readiness probe configured. On Universal, it can be
                         *     set by the external health checking system, but the most common way is
                         *     to use service probes.
                         *
                         *     See https://kuma.io/docs/latest/documentation/health for more
                         *     information. */
                        health?: {
                            /** @description Ready indicates if the data plane proxy is ready to serve the
                             *     traffic. */
                            ready?: boolean;
                        };
                        /** @description Name adds another way of referencing this port, usable with MeshService */
                        name?: string;
                        /** @description Port of the inbound interface that will forward requests to the
                         *     service.
                         *
                         *     When transparent proxying is used, it is a port on which the service is
                         *     listening to. When transparent proxying is not used, Envoy will bind to
                         *     this port. */
                        port?: number;
                        /** @description Address of the service that requests will be forwarded to.
                         *     Defaults to 'inbound.address', since Kuma DP should be deployed next
                         *     to the service. */
                        serviceAddress?: string;
                        /** @description Port of the service that requests will be forwarded to.
                         *     Defaults to the same value as `port`. */
                        servicePort?: number;
                        /** @description ServiceProbe defines parameters for probing the service next to
                         *     sidecar. When service probe is defined, Envoy will periodically health
                         *     check the application next to it and report the status to the control
                         *     plane. On Kubernetes, Kuma deployments rely on Kubernetes probes so
                         *     this is not used.
                         *
                         *     See https://kuma.io/docs/latest/documentation/health for more
                         *     information. */
                        serviceProbe?: {
                            /**
                             * Format: uint32
                             * @description Number of consecutive healthy checks before considering a host
                             *     healthy.
                             */
                            healthyThreshold?: number;
                            /** @description Interval between consecutive health checks. */
                            interval?: {
                                nanos?: number;
                                seconds?: number;
                            };
                            /** @description Tcp checker tries to establish tcp connection with destination */
                            tcp?: Record<string, never>;
                            /** @description Maximum time to wait for a health check response. */
                            timeout?: {
                                nanos?: number;
                                seconds?: number;
                            };
                            /**
                             * Format: uint32
                             * @description Number of consecutive unhealthy checks before considering a host
                             *     unhealthy.
                             */
                            unhealthyThreshold?: number;
                        };
                        /** @description State describes the current state of the listener. */
                        state?: string | number;
                        /** @description Tags associated with an application this data plane proxy is deployed
                         *     next to, e.g. `kuma.io/service=web`, `version=1.0`. You can then
                         *     reference these tags in policies like MeshTrafficPermission.
                         *     `kuma.io/service` tag is mandatory. */
                        tags?: {
                            [key: string]: string;
                        };
                    }[];
                    /** @description Outbound describes a list of services consumed by the data plane proxy.
                     *     For every defined Outbound, there is a corresponding Envoy Listener. */
                    outbound?: {
                        /** @description IP on which the consumed service will be available to this data plane
                         *     proxy. On Kubernetes, it's usually ClusterIP of a Service or PodIP of a
                         *     Headless Service. Defaults to 127.0.0.1 */
                        address?: string;
                        /** @description BackendRef is a way to target MeshService.
                         *     Experimental. Do not use on production yet. */
                        backendRef?: {
                            /** @description Kind is a type of the object to target. Allowed: MeshService */
                            kind?: string;
                            /** @description Labels to select a single object.
                             *     If no object is selected then outbound is not created.
                             *     If multiple objects are selected then the oldest one is used. */
                            labels?: {
                                [key: string]: string;
                            };
                            /** @description Name of the targeted object */
                            name?: string;
                            /** @description Port of the targeted object. Required when kind is MeshService. */
                            port?: number;
                        };
                        /** @description Port on which the consumed service will be available to this data plane
                         *     proxy. When transparent proxying is not used, Envoy will bind to this
                         *     port. */
                        port?: number;
                        /** @description Tags of consumed data plane proxies.
                         *     `kuma.io/service` tag is required.
                         *     These tags can then be referenced in `destinations` section of policies
                         *     like TrafficRoute or in `to` section in policies like MeshAccessLog. It
                         *     is recommended to only use `kuma.io/service`. If you need to consume
                         *     specific data plane proxy of a service (for example: `version=v2`) the
                         *     better practice is to use TrafficRoute. */
                        tags?: {
                            [key: string]: string;
                        };
                    }[];
                    /** @description TransparentProxying describes the configuration for transparent proxying.
                     *     It is used by default on Kubernetes. */
                    transparentProxying?: {
                        /** @description List of services that will be accessed directly via IP:PORT
                         *     Use `*` to indicate direct access to every service in the Mesh.
                         *     Using `*` to directly access every service is a resource-intensive
                         *     operation, use it only if needed. */
                        directAccessServices?: string[];
                        /** @description The IP family mode to enable for. Can be "IPv4" or "DualStack". */
                        ipFamilyMode?: string | number;
                        /** @description Reachable backend via transparent proxy when running with
                         *     MeshExternalService, MeshService and MeshMultiZoneService. Setting an
                         *     explicit list of refs can dramatically improve the performance of the
                         *     mesh. If not specified, all services in the mesh are reachable. */
                        reachableBackends?: {
                            refs?: {
                                /** @description Type of the backend: MeshService or MeshExternalService
                                 *      +required */
                                kind?: string;
                                /** @description Labels used to select backends
                                 *      +optional */
                                labels?: {
                                    [key: string]: string;
                                };
                                /** @description Name of the backend.
                                 *      +optional */
                                name?: string;
                                /** @description Namespace of the backend. Might be empty
                                 *      +optional */
                                namespace?: string;
                                /**
                                 * Format: uint32
                                 * @description Port of the backend.
                                 *      +optional
                                 */
                                port?: number;
                            }[];
                        };
                        /** @description List of reachable services (represented by the value of
                         *     `kuma.io/service`) via transparent proxying. Setting an explicit list
                         *     can dramatically improve the performance of the mesh. If not specified,
                         *     all services in the mesh are reachable. */
                        reachableServices?: string[];
                        /** @description Port on which all inbound traffic is being transparently redirected. */
                        redirectPortInbound?: number;
                        /** @description Port on which all outbound traffic is being transparently redirected. */
                        redirectPortOutbound?: number;
                    };
                };
                /** @description Probes describe a list of endpoints that will be exposed without mTLS.
                 *     This is useful to expose the health endpoints of the application so the
                 *     orchestration system (e.g. Kubernetes) can still health check the
                 *     application.
                 *
                 *     See
                 *     https://kuma.io/docs/latest/policies/service-health-probes/#virtual-probes
                 *     for more information.
                 *     Deprecated: this feature will be removed for Universal; on Kubernetes, it's
                 *     not needed anymore. */
                probes?: {
                    /** @description List of endpoints to expose without mTLS. */
                    endpoints?: {
                        /** @description Inbound path is a path of the application from which we expose the
                         *     endpoint. It is recommended to be as specific as possible. */
                        inboundPath?: string;
                        /** @description Inbound port is a port of the application from which we expose the
                         *     endpoint. */
                        inboundPort?: number;
                        /** @description Path is a path on which we expose inbound path on the probes port. */
                        path?: string;
                    }[];
                    /** @description Port on which the probe endpoints will be exposed. This cannot overlap
                     *     with any other ports. */
                    port?: number;
                };
            };
            dataplaneInsight?: {
                /** @description Insights about mTLS for Dataplane. */
                mTLS?: {
                    /** @description Expiration time of the last certificate that was generated for a
                     *     Dataplane. */
                    certificateExpirationTime?: {
                        nanos?: number;
                        seconds?: number;
                    };
                    /** @description Number of certificate regenerations for a Dataplane. */
                    certificateRegenerations?: number;
                    /** @description Backend that was used to generate current certificate */
                    issuedBackend?: string;
                    /** @description Time on which the last certificate was generated. */
                    lastCertificateRegeneration?: {
                        nanos?: number;
                        seconds?: number;
                    };
                    /** @description Supported backends (CA). */
                    supportedBackends?: string[];
                };
                metadata?: Record<string, never>;
                /** @description List of ADS subscriptions created by a given Dataplane. */
                subscriptions?: {
                    /** @description Time when a given Dataplane connected to the Control Plane. */
                    connectTime?: {
                        nanos?: number;
                        seconds?: number;
                    };
                    /** @description Control Plane instance that handled given subscription. */
                    controlPlaneInstanceId?: string;
                    /** @description Time when a given Dataplane disconnected from the Control Plane. */
                    disconnectTime?: {
                        nanos?: number;
                        seconds?: number;
                    };
                    /** @description Generation is an integer number which is periodically increased by the
                     *     status sink */
                    generation?: number;
                    /** @description Unique id per ADS subscription. */
                    id?: string;
                    /** @description Status of the ADS subscription. */
                    status?: {
                        /** @description CDS defines all CDS stats. */
                        cds?: {
                            /** @description Number of xDS responses ACKed by the Dataplane. */
                            responsesAcknowledged?: number;
                            /** @description Number of xDS responses NACKed by the Dataplane. */
                            responsesRejected?: number;
                            /** @description Number of xDS responses sent to the Dataplane. */
                            responsesSent?: number;
                        };
                        /** @description EDS defines all EDS stats. */
                        eds?: {
                            /** @description Number of xDS responses ACKed by the Dataplane. */
                            responsesAcknowledged?: number;
                            /** @description Number of xDS responses NACKed by the Dataplane. */
                            responsesRejected?: number;
                            /** @description Number of xDS responses sent to the Dataplane. */
                            responsesSent?: number;
                        };
                        /** @description Time when status of a given ADS subscription was most recently updated. */
                        lastUpdateTime?: {
                            nanos?: number;
                            seconds?: number;
                        };
                        /** @description LDS defines all LDS stats. */
                        lds?: {
                            /** @description Number of xDS responses ACKed by the Dataplane. */
                            responsesAcknowledged?: number;
                            /** @description Number of xDS responses NACKed by the Dataplane. */
                            responsesRejected?: number;
                            /** @description Number of xDS responses sent to the Dataplane. */
                            responsesSent?: number;
                        };
                        /** @description RDS defines all RDS stats. */
                        rds?: {
                            /** @description Number of xDS responses ACKed by the Dataplane. */
                            responsesAcknowledged?: number;
                            /** @description Number of xDS responses NACKed by the Dataplane. */
                            responsesRejected?: number;
                            /** @description Number of xDS responses sent to the Dataplane. */
                            responsesSent?: number;
                        };
                        /** @description Total defines an aggregate over individual xDS stats. */
                        total?: {
                            /** @description Number of xDS responses ACKed by the Dataplane. */
                            responsesAcknowledged?: number;
                            /** @description Number of xDS responses NACKed by the Dataplane. */
                            responsesRejected?: number;
                            /** @description Number of xDS responses sent to the Dataplane. */
                            responsesSent?: number;
                        };
                    };
                    /** @description Version of Envoy and Kuma dataplane */
                    version?: {
                        /** @description Versions of other dependencies, i.e. CoreDNS */
                        dependencies?: {
                            [key: string]: string;
                        };
                        /** @description Version of Envoy */
                        envoy?: {
                            /** @description Full build tag of Envoy version */
                            build?: string;
                            /** @description True iff Envoy version is compatible with Kuma DP version */
                            kumaDpCompatible?: boolean;
                            /** @description Version number of Envoy */
                            version?: string;
                        };
                        /** @description Version of Kuma Dataplane */
                        kumaDp?: {
                            /** @description Build date of Kuma Dataplane version */
                            buildDate?: string;
                            /** @description Git commit of Kuma Dataplane version */
                            gitCommit?: string;
                            /** @description Git tag of Kuma Dataplane version */
                            gitTag?: string;
                            /** @description True iff Kuma DP version is compatible with Kuma CP version */
                            kumaCpCompatible?: boolean;
                            /** @description Version number of Kuma Dataplane */
                            version?: string;
                        };
                    };
                }[];
            };
        };
        FileLoggingBackendConfig: {
            /** @description Path to a file that logs will be written to */
            path?: string;
        };
        MeshItem: {
            /** @description Constraints that applies to the mesh and its entities */
            constraints?: {
                /** @description DataplaneProxyMembership defines a set of requirements for data plane
                 *     proxies to be a member of the mesh. */
                dataplaneProxy?: {
                    /** @description Requirements defines a set of requirements that data plane proxies must
                     *     fulfill in order to join the mesh. A data plane proxy must fulfill at
                     *     least one requirement in order to join the mesh. Empty list of allowed
                     *     requirements means that any proxy that is not explicitly denied can join. */
                    requirements?: {
                        /** @description Tags defines set of required tags. You can specify '*' in value to
                         *     require non empty value of tag */
                        tags?: {
                            [key: string]: string;
                        };
                    }[];
                    /** @description Restrictions defines a set of restrictions that data plane proxies cannot
                     *     fulfill in order to join the mesh. A data plane proxy cannot fulfill any
                     *     requirement in order to join the mesh.
                     *     Restrictions takes precedence over requirements. */
                    restrictions?: {
                        /** @description Tags defines set of required tags. You can specify '*' in value to
                         *     require non empty value of tag */
                        tags?: {
                            [key: string]: string;
                        };
                    }[];
                };
            };
            labels?: {
                [key: string]: string;
            };
            /** @description Logging settings.
             *     +optional */
            logging?: {
                /** @description List of available logging backends */
                backends?: {
                    conf?: components["schemas"]["FileLoggingBackendConfig"] | components["schemas"]["TcpLoggingBackendConfig"];
                    /** @description Format of access logs. Placeholders available on
                     *     https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log */
                    format?: string;
                    /** @description Name of the backend, can be then used in Mesh.logging.defaultBackend or in
                     *     TrafficLogging */
                    name?: string;
                    /** @description Type of the backend (Kuma ships with 'tcp' and 'file') */
                    type?: string;
                }[];
                /** @description Name of the default backend */
                defaultBackend?: string;
            };
            meshServices?: {
                /** @enum {string} */
                mode?: "Disabled" | "Everywhere" | "ReachableBackends" | "Exclusive";
            };
            /** @description Configuration for metrics collected and exposed by dataplanes.
             *
             *     Settings defined here become defaults for every dataplane in a given Mesh.
             *     Additionally, it is also possible to further customize this configuration
             *     for each dataplane individually using Dataplane resource.
             *     +optional */
            metrics?: {
                /** @description List of available Metrics backends */
                backends?: {
                    conf?: components["schemas"]["PrometheusMetricsBackendConfig"];
                    /** @description Name of the backend, can be then used in Mesh.metrics.enabledBackend */
                    name?: string;
                    /** @description Type of the backend (Kuma ships with 'prometheus') */
                    type?: string;
                }[];
                /** @description Name of the enabled backend */
                enabledBackend?: string;
            };
            /** @description mTLS settings.
             *     +optional */
            mtls?: {
                /** @description List of available Certificate Authority backends */
                backends?: {
                    conf?: components["schemas"]["ProvidedCertificateAuthorityConfig"] | components["schemas"]["BuiltinCertificateAuthorityConfig"];
                    /** @description Dataplane certificate settings */
                    dpCert?: {
                        /** @description Timeout on request to CA for DP certificate generation and retrieval */
                        requestTimeout?: {
                            nanos?: number;
                            seconds?: number;
                        };
                        /** @description Rotation settings */
                        rotation?: {
                            /** @description Time after which generated certificate for Dataplane will expire */
                            expiration?: string;
                        };
                    };
                    /** @description Mode defines the behaviour of inbound listeners with regard to traffic
                     *     encryption */
                    mode?: string | number;
                    /** @description Name of the backend */
                    name?: string;
                    rootChain?: {
                        /** @description Timeout on request for to CA for root certificate chain.
                         *     If not specified, defaults to 10s. */
                        requestTimeout?: {
                            nanos?: number;
                            seconds?: number;
                        };
                    };
                    /** @description Type of the backend. Has to be one of the loaded plugins (Kuma ships with
                     *     builtin and provided) */
                    type?: string;
                }[];
                /** @description Name of the enabled backend */
                enabledBackend?: string;
                /** @description If enabled, skips CA validation. */
                skipValidation?: boolean;
            };
            name: string;
            /** @description Networking settings of the mesh */
            networking?: {
                /** @description Outbound settings */
                outbound?: {
                    /** @description Control the passthrough cluster */
                    passthrough?: boolean;
                };
            };
            /** @description Routing settings of the mesh */
            routing?: {
                /** @description If true, blocks traffic to MeshExternalServices.
                 *     Default: false */
                defaultForbidMeshExternalServiceAccess?: boolean;
                /** @description Enable the Locality Aware Load Balancing */
                localityAwareLoadBalancing?: boolean;
                /** @description Enable routing traffic to services in other zone or external services
                 *     through ZoneEgress. Default: false */
                zoneEgress?: boolean;
            };
            /** @description List of policies to skip creating by default when the mesh is created.
             *     e.g. TrafficPermission, MeshRetry, etc. An '*' can be used to skip all
             *     policies. */
            skipCreatingInitialPolicies?: string[];
            /** @description Tracing settings.
             *     +optional */
            tracing?: {
                /** @description List of available tracing backends */
                backends?: {
                    conf?: components["schemas"]["DatadogTracingBackendConfig"] | components["schemas"]["ZipkinTracingBackendConfig"];
                    /** @description Name of the backend, can be then used in Mesh.tracing.defaultBackend or in
                     *     TrafficTrace */
                    name?: string;
                    /** @description Percentage of traces that will be sent to the backend (range 0.0 - 100.0).
                     *     Empty value defaults to 100.0% */
                    sampling?: number;
                    /** @description Type of the backend (Kuma ships with 'zipkin') */
                    type?: string;
                }[];
                /** @description Name of the default backend */
                defaultBackend?: string;
            };
            type: string;
            creationTime?: string;
            modificationTime?: string;
        };
        MeshCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshDeleteSuccessResponse: Record<string, never>;
        TcpLoggingBackendConfig: {
            /** @description Address to TCP service that will receive logs */
            address?: string;
        };
        ProvidedCertificateAuthorityConfig: {
            cert?: {
                /** @description Types that are assignable to Type:
                 *     	*DataSource_Secret
                 *     	*DataSource_File
                 *     	*DataSource_Inline
                 *     	*DataSource_InlineString */
                Type: unknown;
            };
            key?: {
                /** @description Types that are assignable to Type:
                 *     	*DataSource_Secret
                 *     	*DataSource_File
                 *     	*DataSource_Inline
                 *     	*DataSource_InlineString */
                Type: unknown;
            };
        };
        ZipkinTracingBackendConfig: {
            /** @description Version of the API. values: httpJson, httpJsonV1, httpProto. Default:
             *     httpJson see
             *     https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/trace.proto#envoy-v3-api-enum-config-trace-v3-zipkinconfig-collectorendpointversion */
            apiVersion?: string;
            /** @description Determines whether client and server spans will share the same span
             *     context. Default: true.
             *     https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/zipkin.proto#config-trace-v3-zipkinconfig */
            sharedSpanContext?: boolean;
            /** @description Generate 128bit traces. Default: false */
            traceId128bit?: boolean;
            /** @description Address of Zipkin collector. */
            url?: string;
        };
        MeshGatewayItem: {
            /** @description The desired configuration of the MeshGateway. */
            conf?: {
                /** @description Listeners define logical endpoints that are bound on this MeshGateway's
                 *     address(es). */
                listeners?: {
                    /** @description CrossMesh enables traffic to flow to this listener only from other
                     *     meshes. */
                    crossMesh?: boolean;
                    /** @description Hostname specifies the virtual hostname to match for protocol types that
                     *     define this concept. When unspecified, "", or `*`, all hostnames are
                     *     matched. This field can be omitted for protocols that don't require
                     *     hostname based matching. */
                    hostname?: string;
                    /** @description Port is the network port. Multiple listeners may use the
                     *     same port, subject to the Listener compatibility rules. */
                    port?: number;
                    /** @description Protocol specifies the network protocol this listener expects to receive. */
                    protocol?: string | number;
                    /** @description Resources is used to specify listener-specific resource settings. */
                    resources?: {
                        connectionLimit?: number;
                    };
                    /** @description Tags specifies a unique combination of tags that routes can use
                     *     to match themselves to this listener.
                     *
                     *     When matching routes to listeners, the control plane constructs a
                     *     set of matching tags for each listener by forming the union of the
                     *     gateway tags and the listener tags. A route will be attached to the
                     *     listener if all of the route's tags are preset in the matching tags */
                    tags?: {
                        [key: string]: string;
                    };
                    /** @description TLS is the TLS configuration for the Listener. This field
                     *     is required if the Protocol field is "HTTPS" or "TLS" and
                     *     ignored otherwise. */
                    tls?: {
                        /** @description Certificates is an array of datasources that contain TLS
                         *     certificates and private keys.  Each datasource must contain a
                         *     sequence of PEM-encoded objects. The server certificate and private
                         *     key are required, but additional certificates are allowed and will
                         *     be added to the certificate chain.  The server certificate must
                         *     be the first certificate in the datasource.
                         *
                         *     When multiple certificate datasources are configured, they must have
                         *     different key types. In practice, this means that one datasource
                         *     should contain an RSA key and certificate, and the other an
                         *     ECDSA key and certificate. */
                        certificates?: {
                            /** @description Types that are assignable to Type:
                             *     	*DataSource_Secret
                             *     	*DataSource_File
                             *     	*DataSource_Inline
                             *     	*DataSource_InlineString */
                            Type: unknown;
                        }[];
                        /** @description Mode defines the TLS behavior for the TLS session initiated
                         *     by the client. */
                        mode?: string | number;
                        /** @description Options should eventually configure how TLS is configured. This
                         *     is where cipher suite and version configuration can be specified,
                         *     client certificates enforced, and so on. */
                        options?: Record<string, never>;
                    };
                }[];
            };
            labels?: {
                [key: string]: string;
            };
            mesh: string;
            name: string;
            /** @description Selectors is a list of selectors that are used to match builtin
             *     gateway dataplanes that will receive this MeshGateway configuration. */
            selectors?: {
                /** @description Tags to match, can be used for both source and destinations */
                match?: {
                    [key: string]: string;
                };
            }[];
            /** @description Tags is the set of tags common to all of the gateway's listeners.
             *
             *     This field must not include a `kuma.io/service` tag (the service is always
             *     defined on the dataplanes). */
            tags?: {
                [key: string]: string;
            };
            type: string;
        };
        MeshGatewayCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshGatewayDeleteSuccessResponse: Record<string, never>;
        Zone: {
            /** @description enable allows to turn the zone on/off and exclude the whole zone from
             *     balancing traffic on it */
            enabled?: boolean;
        };
        HostnameGeneratorItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "HostnameGenerator";
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma HostnameGenerator resource. */
            spec: {
                /** @description Extension struct for a plugin configuration */
                extension?: {
                    /** @description Config freeform configuration for the extension. */
                    config?: unknown;
                    /** @description Type of the extension. */
                    type: string;
                };
                selector?: {
                    meshExternalService?: {
                        matchLabels?: {
                            [key: string]: string;
                        };
                    };
                    meshMultiZoneService?: {
                        matchLabels?: {
                            [key: string]: string;
                        };
                    };
                    meshService?: {
                        matchLabels?: {
                            [key: string]: string;
                        };
                    };
                };
                template: string;
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        HostnameGeneratorCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        HostnameGeneratorDeleteSuccessResponse: Record<string, never>;
        MeshExternalServiceItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshExternalService";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshExternalService resource. */
            spec: {
                /** @description Endpoints defines a list of destinations to send traffic to. */
                endpoints?: {
                    /**
                     * @description Address defines an address to which a user want to send a request. Is possible to provide `domain`, `ip`.
                     * @example example.com
                     */
                    address: string;
                    /**
                     * Format: int32
                     * @description Port of the endpoint
                     */
                    port: number;
                }[];
                /** @description Extension struct for a plugin configuration, in the presence of an extension `endpoints` and `tls` are not required anymore - it's up to the extension to validate them independently. */
                extension?: {
                    /** @description Config freeform configuration for the extension. */
                    config?: unknown;
                    /** @description Type of the extension. */
                    type: string;
                };
                /** @description Match defines traffic that should be routed through the sidecar. */
                match: {
                    /**
                     * Format: int32
                     * @description Port defines a port to which a user does request.
                     */
                    port: number;
                    /**
                     * @description Protocol defines a protocol of the communication. Possible values: `tcp`, `grpc`, `http`, `http2`.
                     * @default tcp
                     * @enum {string}
                     */
                    protocol: "tcp" | "grpc" | "http" | "http2";
                    /**
                     * @description Type of the match, only `HostnameGenerator` is available at the moment.
                     * @default HostnameGenerator
                     * @enum {string}
                     */
                    type: "HostnameGenerator";
                };
                /** @description Tls provides a TLS configuration when proxy is resposible for a TLS origination */
                tls?: {
                    /**
                     * @description AllowRenegotiation defines if TLS sessions will allow renegotiation.
                     *     Setting this to true is not recommended for security reasons.
                     * @default false
                     */
                    allowRenegotiation: boolean;
                    /**
                     * @description Enabled defines if proxy should originate TLS.
                     * @default false
                     */
                    enabled: boolean;
                    /** @description Verification section for providing TLS verification details. */
                    verification?: {
                        /** @description CaCert defines a certificate of CA. */
                        caCert?: {
                            /**
                             * Format: byte
                             * @description Data source is inline bytes.
                             */
                            inline?: string;
                            /** @description Data source is inline string` */
                            inlineString?: string;
                            /** @description Data source is a secret with given Secret key. */
                            secret?: string;
                        };
                        /** @description ClientCert defines a certificate of a client. */
                        clientCert?: {
                            /**
                             * Format: byte
                             * @description Data source is inline bytes.
                             */
                            inline?: string;
                            /** @description Data source is inline string` */
                            inlineString?: string;
                            /** @description Data source is a secret with given Secret key. */
                            secret?: string;
                        };
                        /** @description ClientKey defines a client private key. */
                        clientKey?: {
                            /**
                             * Format: byte
                             * @description Data source is inline bytes.
                             */
                            inline?: string;
                            /** @description Data source is inline string` */
                            inlineString?: string;
                            /** @description Data source is a secret with given Secret key. */
                            secret?: string;
                        };
                        /**
                         * @description Mode defines if proxy should skip verification, one of `SkipSAN`, `SkipCA`, `Secured`, `SkipAll`. Default `Secured`.
                         * @default Secured
                         * @enum {string}
                         */
                        mode: "SkipSAN" | "SkipCA" | "Secured" | "SkipAll";
                        /** @description ServerName overrides the default Server Name Indicator set by Kuma. */
                        serverName?: string;
                        /** @description SubjectAltNames list of names to verify in the certificate. */
                        subjectAltNames?: {
                            /**
                             * @description Type specifies matching type, one of `Exact`, `Prefix`. Default: `Exact`
                             * @default Exact
                             * @enum {string}
                             */
                            type: "Exact" | "Prefix";
                            /** @description Value to match. */
                            value: string;
                        }[];
                    };
                    /** @description Version section for providing version specification. */
                    version?: {
                        /**
                         * @description Max defines maximum supported version. One of `TLSAuto`, `TLS10`, `TLS11`, `TLS12`, `TLS13`.
                         * @default TLSAuto
                         * @enum {string}
                         */
                        max: "TLSAuto" | "TLS10" | "TLS11" | "TLS12" | "TLS13";
                        /**
                         * @description Min defines minimum supported version. One of `TLSAuto`, `TLS10`, `TLS11`, `TLS12`, `TLS13`.
                         * @default TLSAuto
                         * @enum {string}
                         */
                        min: "TLSAuto" | "TLS10" | "TLS11" | "TLS12" | "TLS13";
                    };
                };
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
            /** @description Status is the current status of the Kuma MeshExternalService resource. */
            readonly status?: {
                /** @description Addresses section for generated domains */
                addresses?: {
                    hostname?: string;
                    hostnameGeneratorRef?: {
                        coreName: string;
                    };
                    origin?: string;
                }[];
                hostnameGenerators?: {
                    /** @description Conditions is an array of hostname generator conditions. */
                    conditions?: {
                        /** @description message is a human readable message indicating details about the transition.
                         *     This may be an empty string. */
                        message: string;
                        /** @description reason contains a programmatic identifier indicating the reason for the condition's last transition.
                         *     Producers of specific condition types may define expected values and meanings for this field,
                         *     and whether the values are considered a guaranteed API.
                         *     The value should be a CamelCase string.
                         *     This field may not be empty. */
                        reason: string;
                        /**
                         * @description status of the condition, one of True, False, Unknown.
                         * @enum {string}
                         */
                        status: "True" | "False" | "Unknown";
                        /** @description type of condition in CamelCase or in foo.example.com/CamelCase. */
                        type: string;
                    }[];
                    hostnameGeneratorRef: {
                        coreName: string;
                    };
                }[];
                /** @description Vip section for allocated IP */
                vip?: {
                    /** @description Value allocated IP for a provided domain with `HostnameGenerator` type in a match section. */
                    ip?: string;
                };
            };
        };
        MeshExternalServiceCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshExternalServiceDeleteSuccessResponse: Record<string, never>;
        MeshIdentityItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshIdentity";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshIdentity resource. */
            spec: {
                provider: {
                    /** @description Bundled provides information about certificates that are generated by the control plane,
                     *     either autogenerated or provided by the user. */
                    bundled?: {
                        /** @description Autogenerate configures the control plane to use self-signed certificates. */
                        autogenerate?: {
                            enabled?: boolean;
                        };
                        /** @description CA has configuration related to the CA */
                        ca?: {
                            /** @description Certificate allows the user to specify a custom certificate. */
                            certificate?: {
                                envVar?: {
                                    name: string;
                                };
                                file?: {
                                    path: string;
                                };
                                insecureInline?: {
                                    value: string;
                                };
                                secretRef?: {
                                    /** @enum {string} */
                                    kind: "Secret";
                                    name: string;
                                };
                                /** @enum {string} */
                                type: "File" | "Secret" | "EnvVar" | "InsecureInline";
                            };
                            /** @description PrivateKey allows the user to specify a custom private key. */
                            privateKey?: {
                                envVar?: {
                                    name: string;
                                };
                                file?: {
                                    path: string;
                                };
                                insecureInline?: {
                                    value: string;
                                };
                                secretRef?: {
                                    /** @enum {string} */
                                    kind: "Secret";
                                    name: string;
                                };
                                /** @enum {string} */
                                type: "File" | "Secret" | "EnvVar" | "InsecureInline";
                            };
                        };
                        /** @description CertificateParameters allows users to define certificate generation parameters. */
                        certificateParameters?: {
                            expiry?: string;
                        };
                        /** @description InsecureAllowSelfSigned allows users to enable the use of self-signed certificates. */
                        insecureAllowSelfSigned?: boolean;
                        /**
                         * @description MeshTrustCreation defines whether a MeshTrust resource should be automatically created
                         *     from an existing MeshIdentity. If not defined, the control plane automatically generates a MeshTrust.
                         * @enum {string}
                         */
                        meshTrustCreation?: "Enabled" | "Disabled";
                    };
                    /** @description Spire indicates that SPIRE is used for certificate delivery. */
                    spire?: {
                        /** @description Spire agent configuration */
                        agent?: {
                            /** @description Connection timeout to the socket exposed by Spire agent
                             *     Default 1 second. */
                            timeout?: string;
                        };
                    };
                    /**
                     * @description Type specifies the type of certificate provider.
                     * @enum {string}
                     */
                    type: "Bundled" | "Spire";
                };
                selector?: {
                    dataplane?: {
                        matchLabels?: {
                            [key: string]: string;
                        };
                    };
                };
                spiffeID?: {
                    path?: string;
                    trustDomain?: string;
                };
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
            /** @description Status is the current status of the Kuma MeshIdentity resource. */
            readonly status?: {
                /** @description Conditions is an array of hostname generator conditions. */
                conditions?: {
                    /** @description message is a human readable message indicating details about the transition.
                     *     This may be an empty string. */
                    message: string;
                    /** @description reason contains a programmatic identifier indicating the reason for the condition's last transition.
                     *     Producers of specific condition types may define expected values and meanings for this field,
                     *     and whether the values are considered a guaranteed API.
                     *     The value should be a CamelCase string.
                     *     This field may not be empty. */
                    reason: string;
                    /**
                     * @description status of the condition, one of True, False, Unknown.
                     * @enum {string}
                     */
                    status: "True" | "False" | "Unknown";
                    /** @description type of condition in CamelCase or in foo.example.com/CamelCase. */
                    type: string;
                }[];
            };
        };
        MeshIdentityCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshIdentityDeleteSuccessResponse: Record<string, never>;
        MeshMultiZoneServiceItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshMultiZoneService";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshMultiZoneService resource. */
            spec: {
                /** @description Ports is a list of ports from selected MeshServices */
                ports: {
                    /**
                     * @description Protocol identifies a protocol supported by a service.
                     * @default tcp
                     */
                    appProtocol: string;
                    name?: string;
                    /** Format: int32 */
                    port: number;
                }[];
                /** @description Selector is a way to select multiple MeshServices */
                selector: {
                    /** @description MeshService selects MeshServices */
                    meshService: {
                        matchLabels?: {
                            [key: string]: string;
                        };
                    };
                };
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
            /** @description Status is the current status of the Kuma MeshMultiZoneService resource. */
            readonly status?: {
                /** @description Addresses is a list of addresses generated by HostnameGenerator */
                addresses?: {
                    hostname?: string;
                    hostnameGeneratorRef?: {
                        coreName: string;
                    };
                    origin?: string;
                }[];
                /** @description Status of hostnames generator applied on this resource */
                hostnameGenerators?: {
                    /** @description Conditions is an array of hostname generator conditions. */
                    conditions?: {
                        /** @description message is a human readable message indicating details about the transition.
                         *     This may be an empty string. */
                        message: string;
                        /** @description reason contains a programmatic identifier indicating the reason for the condition's last transition.
                         *     Producers of specific condition types may define expected values and meanings for this field,
                         *     and whether the values are considered a guaranteed API.
                         *     The value should be a CamelCase string.
                         *     This field may not be empty. */
                        reason: string;
                        /**
                         * @description status of the condition, one of True, False, Unknown.
                         * @enum {string}
                         */
                        status: "True" | "False" | "Unknown";
                        /** @description type of condition in CamelCase or in foo.example.com/CamelCase. */
                        type: string;
                    }[];
                    hostnameGeneratorRef: {
                        coreName: string;
                    };
                }[];
                /** @description MeshServices is a list of matched MeshServices */
                meshServices?: {
                    mesh: string;
                    /** @description Name is a core name of MeshService */
                    name: string;
                    namespace: string;
                    zone: string;
                }[];
                /** @description VIPs is a list of assigned Kuma VIPs. */
                vips?: {
                    ip?: string;
                }[];
            };
        };
        MeshMultiZoneServiceCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshMultiZoneServiceDeleteSuccessResponse: Record<string, never>;
        MeshServiceItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshService";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshService resource. */
            spec: {
                identities?: {
                    /** @enum {string} */
                    type: "ServiceTag";
                    value: string;
                }[];
                ports?: {
                    /**
                     * @description Protocol identifies a protocol supported by a service.
                     * @default tcp
                     */
                    appProtocol: string;
                    name?: string;
                    /** Format: int32 */
                    port: number;
                    targetPort?: number | string;
                }[];
                selector?: {
                    dataplaneRef?: {
                        name?: string;
                    };
                    dataplaneTags?: {
                        [key: string]: string;
                    };
                };
                /**
                 * @description State of MeshService. Available if there is at least one healthy endpoint. Otherwise, Unavailable.
                 *     It's used for cross zone communication to check if we should send traffic to it, when MeshService is aggregated into MeshMultiZoneService.
                 * @default Unavailable
                 * @enum {string}
                 */
                state: "Available" | "Unavailable";
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
            /** @description Status is the current status of the Kuma MeshService resource. */
            readonly status?: {
                addresses?: {
                    hostname?: string;
                    hostnameGeneratorRef?: {
                        coreName: string;
                    };
                    origin?: string;
                }[];
                /** @description Data plane proxies statistics selected by this MeshService. */
                dataplaneProxies?: {
                    /** @description Number of data plane proxies connected to the zone control plane */
                    connected?: number;
                    /** @description Number of data plane proxies with all healthy inbounds selected by this MeshService. */
                    healthy?: number;
                    /** @description Total number of data plane proxies. */
                    total?: number;
                };
                hostnameGenerators?: {
                    /** @description Conditions is an array of hostname generator conditions. */
                    conditions?: {
                        /** @description message is a human readable message indicating details about the transition.
                         *     This may be an empty string. */
                        message: string;
                        /** @description reason contains a programmatic identifier indicating the reason for the condition's last transition.
                         *     Producers of specific condition types may define expected values and meanings for this field,
                         *     and whether the values are considered a guaranteed API.
                         *     The value should be a CamelCase string.
                         *     This field may not be empty. */
                        reason: string;
                        /**
                         * @description status of the condition, one of True, False, Unknown.
                         * @enum {string}
                         */
                        status: "True" | "False" | "Unknown";
                        /** @description type of condition in CamelCase or in foo.example.com/CamelCase. */
                        type: string;
                    }[];
                    hostnameGeneratorRef: {
                        coreName: string;
                    };
                }[];
                tls?: {
                    /** @enum {string} */
                    status?: "Ready" | "NotReady";
                };
                vips?: {
                    ip?: string;
                }[];
            };
        };
        MeshServiceCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshServiceDeleteSuccessResponse: Record<string, never>;
        MeshTrustItem: {
            /**
             * @description the type of the resource
             * @enum {string}
             */
            type: "MeshTrust";
            /**
             * @description Mesh is the name of the Kuma mesh this resource belongs to. It may be omitted for cluster-scoped resources.
             * @default default
             */
            mesh: string;
            /** @description Name of the Kuma resource */
            name: string;
            /** @description The labels to help identity resources */
            labels?: {
                [key: string]: string;
            };
            /** @description Spec is the specification of the Kuma MeshTrust resource. */
            spec: {
                /** @description CABundles contains a list of CA bundles supported by this TrustDomain.
                 *     At least one CA bundle must be specified. */
                caBundles: {
                    /** @description Pem contains the PEM-encoded CA bundle if the Type is set to a PEM-based format. */
                    pem?: {
                        /** @description Value holds the PEM-encoded CA bundle as a string. */
                        value: string;
                    };
                    /**
                     * @description Type specifies the format or source type of the CA bundle.
                     * @enum {string}
                     */
                    type: "Pem";
                }[];
                /** @description Origin specifies whether the resource was created from a MeshIdentity. */
                origin?: {
                    /** @description Resource identifier */
                    kri?: string;
                };
                /** @description TrustDomain is the trust domain associated with this resource. */
                trustDomain: string;
            };
            /**
             * Format: date-time
             * @description Time at which the resource was created
             * @example 0001-01-01T00:00:00Z
             */
            readonly creationTime?: string;
            /**
             * Format: date-time
             * @description Time at which the resource was updated
             * @example 0001-01-01T00:00:00Z
             */
            readonly modificationTime?: string;
        };
        MeshTrustCreateOrUpdateSuccessResponse: {
            /** @description warnings is a list of warning messages to return to the requesting Kuma API clients.
             *     Warning messages describe a problem the client making the API request should correct or be aware of.
             *      */
            readonly warnings?: string[];
        };
        MeshTrustDeleteSuccessResponse: Record<string, never>;
        ControlPlaneConfig: unknown;
        MeshInsight: components["schemas"]["Entity"] & {
            /** @enum {string} */
            type?: "MeshInsight";
            lastSync?: string;
            dataplanes?: components["schemas"]["MeshInsightDataplaneStatistics"];
            dataplanesByType?: {
                standard?: components["schemas"]["MeshInsightDataplaneStatistics"];
                gateway?: components["schemas"]["MeshInsightDataplaneStatistics"];
                gatewayBuiltin?: components["schemas"]["MeshInsightDataplaneStatistics"];
                gatewayDelegated?: components["schemas"]["MeshInsightDataplaneStatistics"];
            };
            policies?: {
                [key: string]: {
                    total?: number;
                };
            };
            resources?: {
                [key: string]: {
                    total?: number;
                };
            };
            dpVersions?: {
                kumaDp?: {
                    [key: string]: components["schemas"]["MeshInsightDataplaneStatistics"];
                };
                envoy?: {
                    [key: string]: components["schemas"]["MeshInsightDataplaneStatistics"];
                };
            };
            mTLS?: {
                issuedBackends?: {
                    [key: string]: components["schemas"]["MeshInsightDataplaneStatistics"];
                };
                supportedBackends?: {
                    [key: string]: components["schemas"]["MeshInsightDataplaneStatistics"];
                };
            };
            services?: {
                total?: number;
                internal?: number;
                external?: number;
            };
        };
        MeshInsightCollection: components["schemas"]["PagedCollection"] & {
            items?: components["schemas"]["MeshInsight"][];
        };
        PagedCollection: {
            total: number;
            items: Record<string, never>[];
            next: string | null;
        };
        Entity: {
            name: string;
            creationTime: string;
            modificationTime: string;
        };
        MeshInsightDataplaneStatistics: {
            total?: number;
            online?: number;
            offline?: number;
            partiallyDegraded?: number;
        };
    };
    responses: {
        /** @description A response for the index endpoint */
        IndexResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Index"];
            };
        };
        /** @description A response containing a list of all resources installed in Kuma */
        ResourceTypeDescriptionListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ResourceTypeDescriptionList"];
            };
        };
        /** @description A response containing global insight. */
        GlobalInsightResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["GlobalInsight"];
            };
        };
        /** @description A response containing dataplanes that match a policy. */
        InspectDataplanesForPolicyResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["InspectDataplanesForPolicy"];
            };
        };
        /** @description Successfully retrieved proxy XDS config. */
        GetDataplaneXDSConfigResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["DataplaneXDSConfig"];
            };
        };
        /** @description A response containing policies that match a resource */
        InspectRulesResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["InspectRules"];
            };
        };
        /** @description A response containing hostnames that match a service. */
        InspectHostnamesResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["InspectHostnames"];
            };
        };
        /** @description A response containing dataplane networking layout. */
        DataplaneNetworkingLayoutResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["DataplaneNetworkingLayout"];
            };
        };
        /** @description A response containing policies configuration for selected dataplane */
        ProxyPolicyConfResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PoliciesList"];
            };
        };
        /** @description A response containing policies configuration for selected inbound */
        InboundPolicyConfResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["InboundPoliciesList"];
            };
        };
        /** @description A response containing policies configuration for selected outbound */
        OutboundPolicyConfResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PoliciesList"];
            };
        };
        /** @description A response containing routes configuration for selected outbound */
        RoutesListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["RoutesList"];
            };
        };
        /** @description A response containing policies configuration for selected route */
        RoutePolicyConfResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["PoliciesList"];
            };
        };
        /** @description Bad Request */
        BadRequest: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Error"];
            };
        };
        /** @description Internal Server Error */
        Internal: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Error"];
            };
        };
        /** @description Bad Request */
        "responses-BadRequest": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Error"];
            };
        };
        /** @description Internal Server Error */
        "responses-Internal": {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["Error"];
            };
        };
        /** @description Not Found */
        NotFound: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/problem+json": components["schemas"]["NotFoundError"];
            };
        };
        /** @description Successful response */
        MeshAccessLogItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshAccessLogItem"];
            };
        };
        /** @description List */
        MeshAccessLogList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshAccessLogItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshCircuitBreakerItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshCircuitBreakerItem"];
            };
        };
        /** @description List */
        MeshCircuitBreakerList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshCircuitBreakerItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshFaultInjectionItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshFaultInjectionItem"];
            };
        };
        /** @description List */
        MeshFaultInjectionList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshFaultInjectionItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshHealthCheckItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshHealthCheckItem"];
            };
        };
        /** @description List */
        MeshHealthCheckList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshHealthCheckItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshHTTPRouteItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshHTTPRouteItem"];
            };
        };
        /** @description List */
        MeshHTTPRouteList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshHTTPRouteItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshLoadBalancingStrategyItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshLoadBalancingStrategyItem"];
            };
        };
        /** @description List */
        MeshLoadBalancingStrategyList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshLoadBalancingStrategyItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshMetricItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshMetricItem"];
            };
        };
        /** @description List */
        MeshMetricList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshMetricItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshPassthroughItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshPassthroughItem"];
            };
        };
        /** @description List */
        MeshPassthroughList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshPassthroughItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshProxyPatchItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshProxyPatchItem"];
            };
        };
        /** @description List */
        MeshProxyPatchList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshProxyPatchItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshRateLimitItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshRateLimitItem"];
            };
        };
        /** @description List */
        MeshRateLimitList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshRateLimitItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshRetryItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshRetryItem"];
            };
        };
        /** @description List */
        MeshRetryList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshRetryItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshTCPRouteItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshTCPRouteItem"];
            };
        };
        /** @description List */
        MeshTCPRouteList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshTCPRouteItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshTimeoutItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshTimeoutItem"];
            };
        };
        /** @description List */
        MeshTimeoutList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshTimeoutItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshTLSItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshTLSItem"];
            };
        };
        /** @description List */
        MeshTLSList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshTLSItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshTraceItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshTraceItem"];
            };
        };
        /** @description List */
        MeshTraceList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshTraceItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshTrafficPermissionItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshTrafficPermissionItem"];
            };
        };
        /** @description List */
        MeshTrafficPermissionList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshTrafficPermissionItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        DataplaneItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["DataplaneItem"];
            };
        };
        /** @description List */
        DataplaneList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["DataplaneItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description A response containing the overview of a dataplane. */
        GetDataplaneOverviewResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["DataplaneOverviewWithMeta"];
            };
        };
        /** @description A response containing the overview of a dataplane. */
        GetDataplaneOverviewListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @example 200 */
                    total?: number;
                    next?: string;
                    items?: components["schemas"]["DataplaneOverviewWithMeta"][];
                };
            };
        };
        /** @description Successful response */
        MeshItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshItem"];
            };
        };
        /** @description List */
        MeshList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshGatewayItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshGatewayItem"];
            };
        };
        /** @description List */
        MeshGatewayList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshGatewayItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        HostnameGeneratorItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["HostnameGeneratorItem"];
            };
        };
        /** @description List */
        HostnameGeneratorList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["HostnameGeneratorItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshExternalServiceItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshExternalServiceItem"];
            };
        };
        /** @description List */
        MeshExternalServiceList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshExternalServiceItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshIdentityItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshIdentityItem"];
            };
        };
        /** @description List */
        MeshIdentityList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshIdentityItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshMultiZoneServiceItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshMultiZoneServiceItem"];
            };
        };
        /** @description List */
        MeshMultiZoneServiceList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshMultiZoneServiceItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshServiceItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshServiceItem"];
            };
        };
        /** @description List */
        MeshServiceList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshServiceItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
        /** @description Successful response */
        MeshTrustItem: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MeshTrustItem"];
            };
        };
        /** @description List */
        MeshTrustList: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    items?: components["schemas"]["MeshTrustItem"][];
                    /** @description The total number of entities */
                    total?: number;
                    /** @description URL to the next page */
                    next?: string;
                };
            };
        };
    };
    parameters: {
        name: string;
        size: number;
        offset: number;
        filter: {
            key?: string;
            value?: string;
        };
        format: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    index: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["IndexResponse"];
            400: components["responses"]["responses-BadRequest"];
            500: components["responses"]["responses-Internal"];
        };
    };
    "get-resource-type-description": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ResourceTypeDescriptionListResponse"];
            400: components["responses"]["responses-BadRequest"];
            500: components["responses"]["responses-Internal"];
        };
    };
    "get-global-insight": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GlobalInsightResponse"];
            400: components["responses"]["responses-BadRequest"];
            500: components["responses"]["responses-Internal"];
        };
    };
    "inspect-dataplanes-rules": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /**
                 * @description The mesh the policy is part of
                 * @example default
                 */
                mesh: string;
                /**
                 * @description The type of resource (only some resources support rules api)
                 * @example dataplanes
                 */
                resourceType: "dataplanes" | "meshgateways";
                /**
                 * @description The name of the resource
                 * @example my-dp
                 */
                resourceName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["InspectRulesResponse"];
            400: components["responses"]["responses-BadRequest"];
            500: components["responses"]["responses-Internal"];
        };
    };
    "get-dataplanes-xds-config": {
        parameters: {
            query?: {
                /** @description When computing XDS config the CP take into account policies with 'kuma.io/effect: shadow' label
                 *      */
                shadow?: boolean;
                /** @description An array of extra fields to include in the response. When `include=diff` the server computes a diff in JSONPatch format
                 *     between the current proxy XDS config and the config returned in the 'xds' field.
                 *      */
                include?: "diff"[];
            };
            header?: never;
            path: {
                /** @description The mesh of the DPP to get the diff for. */
                mesh: string;
                /** @description The name of the DPP within the mesh to get the diff for. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GetDataplaneXDSConfigResponse"];
            400: components["responses"]["responses-BadRequest"];
            500: components["responses"]["Internal"];
        };
    };
    "get-dataplanes-layout": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The mesh of the DPP to get the layout for. */
                mesh: string;
                /** @description The name of the DPP within the mesh to get the layout for. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["DataplaneNetworkingLayoutResponse"];
            400: components["responses"]["responses-BadRequest"];
            500: components["responses"]["Internal"];
        };
    };
    "get-proxy-policy-conf": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The mesh of the DPP to get the diff for. */
                mesh: string;
                /** @description The name of the DPP within the mesh to get the diff for. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["ProxyPolicyConfResponse"];
            400: components["responses"]["responses-BadRequest"];
            500: components["responses"]["Internal"];
        };
    };
    "get-inbound-policy-conf": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The mesh of the DPP to get the policies for. */
                mesh: string;
                /** @description The name of the DPP within the mesh to get the policies for. */
                name: string;
                /** @description The name of the Inbound from DPP to get the policies for. */
                "inbound-kri": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["InboundPolicyConfResponse"];
            400: components["responses"]["responses-BadRequest"];
            500: components["responses"]["Internal"];
        };
    };
    "get-outbound-policy-conf": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The mesh of the DPP to get the policies for. */
                mesh: string;
                /** @description The name of the DPP within the mesh to get the policies for. */
                name: string;
                /** @description The KRI of the Outbound to get the policies for. */
                kri: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OutboundPolicyConfResponse"];
            400: components["responses"]["responses-BadRequest"];
            500: components["responses"]["Internal"];
        };
    };
    "get-outbound-routes": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The mesh of the DPP to get the policies for. */
                mesh: string;
                /** @description The name of the DPP within the mesh to get the policies for. */
                name: string;
                /** @description The KRI of the Outbound to get the routes for. */
                kri: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RoutesListResponse"];
            400: components["responses"]["responses-BadRequest"];
            500: components["responses"]["Internal"];
        };
    };
    "get-route-policy-conf": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The mesh of the DPP to get the policies for. */
                mesh: string;
                /** @description The name of the DPP within the mesh to get the policies for. */
                name: string;
                /** @description The KRI of the Outbound to get the routes for. */
                "outbound-kri": string;
                /** @description The KRI of the Route to get the configuration for. */
                "route-kri": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["RoutePolicyConfResponse"];
            400: components["responses"]["responses-BadRequest"];
            500: components["responses"]["Internal"];
        };
    };
    "inspect-resources": {
        parameters: {
            query?: {
                /** @description The max number of items to return */
                size?: number;
                /** @description The offset of result */
                offset?: number;
                /** @description A sub string to filter resources by name */
                name?: string;
            };
            header?: never;
            path: {
                /**
                 * @description The mesh the policy is part of
                 * @example default
                 */
                mesh: string;
                /**
                 * @description The type of the policy
                 * @example meshretries
                 */
                policyType: string;
                /**
                 * @description The type of the policy
                 * @example retry-all
                 */
                policyName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["InspectDataplanesForPolicyResponse"];
            400: components["responses"]["responses-BadRequest"];
            500: components["responses"]["Internal"];
        };
    };
    "inspect-hostnames": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /**
                 * @description The mesh the service is part of
                 * @example default
                 */
                mesh: string;
                /**
                 * @description The type of the service
                 * @example meshservices
                 */
                serviceType: "meshservices" | "meshmultizoneservices" | "meshexternalservices";
                /**
                 * @description The name of the service
                 * @example redis
                 */
                serviceName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["InspectHostnamesResponse"];
            400: components["responses"]["responses-BadRequest"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["Internal"];
        };
    };
    getMeshAccessLog: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshAccessLog */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshAccessLogItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshAccessLog: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshAccessLog */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshAccessLogItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshAccessLogCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshAccessLogCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshAccessLog: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshAccessLog */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshAccessLogDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshAccessLogList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshAccessLogList"];
        };
    };
    getMeshCircuitBreaker: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshCircuitBreaker */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshCircuitBreakerItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshCircuitBreaker: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshCircuitBreaker */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshCircuitBreakerItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshCircuitBreakerCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshCircuitBreakerCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshCircuitBreaker: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshCircuitBreaker */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshCircuitBreakerDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshCircuitBreakerList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshCircuitBreakerList"];
        };
    };
    getMeshFaultInjection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshFaultInjection */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshFaultInjectionItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshFaultInjection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshFaultInjection */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshFaultInjectionItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshFaultInjectionCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshFaultInjectionCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshFaultInjection: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshFaultInjection */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshFaultInjectionDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshFaultInjectionList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshFaultInjectionList"];
        };
    };
    getMeshHealthCheck: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshHealthCheck */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshHealthCheckItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshHealthCheck: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshHealthCheck */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshHealthCheckItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshHealthCheckCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshHealthCheckCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshHealthCheck: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshHealthCheck */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshHealthCheckDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshHealthCheckList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshHealthCheckList"];
        };
    };
    getMeshHTTPRoute: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshHTTPRoute */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshHTTPRouteItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshHTTPRoute: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshHTTPRoute */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshHTTPRouteItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshHTTPRouteCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshHTTPRouteCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshHTTPRoute: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshHTTPRoute */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshHTTPRouteDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshHTTPRouteList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshHTTPRouteList"];
        };
    };
    getMeshLoadBalancingStrategy: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshLoadBalancingStrategy */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshLoadBalancingStrategyItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshLoadBalancingStrategy: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshLoadBalancingStrategy */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshLoadBalancingStrategyItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshLoadBalancingStrategyCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshLoadBalancingStrategyCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshLoadBalancingStrategy: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshLoadBalancingStrategy */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshLoadBalancingStrategyDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshLoadBalancingStrategyList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshLoadBalancingStrategyList"];
        };
    };
    getMeshMetric: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshMetric */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshMetricItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshMetric: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshMetric */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshMetricItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshMetricCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshMetricCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshMetric: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshMetric */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshMetricDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshMetricList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshMetricList"];
        };
    };
    getMeshPassthrough: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshPassthrough */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshPassthroughItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshPassthrough: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshPassthrough */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshPassthroughItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshPassthroughCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshPassthroughCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshPassthrough: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshPassthrough */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshPassthroughDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshPassthroughList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshPassthroughList"];
        };
    };
    getMeshProxyPatch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshProxyPatch */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshProxyPatchItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshProxyPatch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshProxyPatch */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshProxyPatchItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshProxyPatchCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshProxyPatchCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshProxyPatch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshProxyPatch */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshProxyPatchDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshProxyPatchList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshProxyPatchList"];
        };
    };
    getMeshRateLimit: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshRateLimit */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshRateLimitItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshRateLimit: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshRateLimit */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshRateLimitItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshRateLimitCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshRateLimitCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshRateLimit: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshRateLimit */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshRateLimitDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshRateLimitList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshRateLimitList"];
        };
    };
    getMeshRetry: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshRetry */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshRetryItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshRetry: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshRetry */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshRetryItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshRetryCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshRetryCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshRetry: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshRetry */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshRetryDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshRetryList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshRetryList"];
        };
    };
    getMeshTCPRoute: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTCPRoute */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshTCPRouteItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshTCPRoute: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTCPRoute */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshTCPRouteItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTCPRouteCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTCPRouteCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshTCPRoute: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTCPRoute */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTCPRouteDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshTCPRouteList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshTCPRouteList"];
        };
    };
    getMeshTimeout: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTimeout */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshTimeoutItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshTimeout: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTimeout */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshTimeoutItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTimeoutCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTimeoutCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshTimeout: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTimeout */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTimeoutDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshTimeoutList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshTimeoutList"];
        };
    };
    getMeshTLS: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTLS */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshTLSItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshTLS: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTLS */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshTLSItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTLSCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTLSCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshTLS: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTLS */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTLSDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshTLSList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshTLSList"];
        };
    };
    getMeshTrace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTrace */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshTraceItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshTrace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTrace */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshTraceItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTraceCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTraceCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshTrace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTrace */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTraceDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshTraceList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshTraceList"];
        };
    };
    getMeshTrafficPermission: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTrafficPermission */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshTrafficPermissionItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshTrafficPermission: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTrafficPermission */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshTrafficPermissionItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTrafficPermissionCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTrafficPermissionCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshTrafficPermission: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTrafficPermission */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTrafficPermissionDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshTrafficPermissionList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshTrafficPermissionList"];
        };
    };
    getDataplane: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the Dataplane */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["DataplaneItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putDataplane: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the Dataplane */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["DataplaneItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DataplaneCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DataplaneCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteDataplane: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the Dataplane */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DataplaneDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getDataplaneList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["DataplaneList"];
        };
    };
    getDataplaneOverview: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The mesh of the DPP to get the diff for. */
                mesh: string;
                /** @description The name of the DPP within the mesh to get the diff for. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GetDataplaneOverviewResponse"];
            400: components["responses"]["BadRequest"];
            500: components["responses"]["Internal"];
        };
    };
    getDataplaneOverviewList: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The mesh of the DPP to get the diff for. */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["GetDataplaneOverviewListResponse"];
            400: components["responses"]["BadRequest"];
            500: components["responses"]["Internal"];
        };
    };
    getMesh: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the Mesh */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMesh: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the Mesh */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMesh: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the Mesh */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshList"];
        };
    };
    getMeshGateway: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshGateway */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshGatewayItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshGateway: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshGateway */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshGatewayItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshGatewayCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshGatewayCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshGateway: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshGateway */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshGatewayDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshGatewayList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshGatewayList"];
        };
    };
    getHostnameGenerator: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the HostnameGenerator */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["HostnameGeneratorItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putHostnameGenerator: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the HostnameGenerator */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["HostnameGeneratorItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HostnameGeneratorCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HostnameGeneratorCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteHostnameGenerator: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the HostnameGenerator */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HostnameGeneratorDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getHostnameGeneratorList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["HostnameGeneratorList"];
        };
    };
    getMeshExternalService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshExternalService */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshExternalServiceItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshExternalService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshExternalService */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshExternalServiceItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshExternalServiceCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshExternalServiceCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshExternalService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshExternalService */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshExternalServiceDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshExternalServiceList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshExternalServiceList"];
        };
    };
    getMeshIdentity: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshIdentity */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshIdentityItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshIdentity: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshIdentity */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshIdentityItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshIdentityCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshIdentityCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshIdentity: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshIdentity */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshIdentityDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshIdentityList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshIdentityList"];
        };
    };
    getMeshMultiZoneService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshMultiZoneService */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshMultiZoneServiceItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshMultiZoneService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshMultiZoneService */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshMultiZoneServiceItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshMultiZoneServiceCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshMultiZoneServiceCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshMultiZoneService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshMultiZoneService */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshMultiZoneServiceDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshMultiZoneServiceList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshMultiZoneServiceList"];
        };
    };
    getMeshService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshService */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshServiceItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshService */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshServiceItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshServiceCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshServiceCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshService: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshService */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshServiceDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshServiceList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshServiceList"];
        };
    };
    getMeshTrust: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTrust */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshTrustItem"];
            404: components["responses"]["NotFound"];
        };
    };
    putMeshTrust: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTrust */
                name: string;
            };
            cookie?: never;
        };
        /** @description Put request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeshTrustItem"];
            };
        };
        responses: {
            /** @description Updated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTrustCreateOrUpdateSuccessResponse"];
                };
            };
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTrustCreateOrUpdateSuccessResponse"];
                };
            };
        };
    };
    deleteMeshTrust: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
                /** @description name of the MeshTrust */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeshTrustDeleteSuccessResponse"];
                };
            };
            404: components["responses"]["NotFound"];
        };
    };
    getMeshTrustList: {
        parameters: {
            query?: {
                /**
                 * @description offset in the list of entities
                 * @example 0
                 */
                offset?: number;
                /** @description the number of items per page */
                size?: number;
                /**
                 * @description filter by labels when multiple filters are present, they are ANDed
                 * @example {
                 *       "label.k8s.kuma.io/namespace": "my-ns"
                 *     }
                 */
                filter?: {
                    key?: string;
                    value?: string;
                };
            };
            header?: never;
            path: {
                /** @description name of the mesh */
                mesh: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["MeshTrustList"];
        };
    };
}
